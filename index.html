<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<meta name="color-scheme" content="light dark" />
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet" />

		<title>ectl.me</title>
		<style>
			/* â”€â”€ Light palette â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
			:root {
				--bg: #f0f2f8;
				--text: #0f1117;
				--muted: #697285;
				--accent: #5b6ef5;
				--accent-2: #a855f7;
				--accent-glow: rgba(91,110,245,0.22);
				--accent-glow-2: rgba(168,85,247,0.14);
				--ring: rgba(91,110,245,0.35);
				--link: var(--accent);
				--card-bg: rgba(255,255,255,0.68);
				--card-border: rgba(255,255,255,0.85);
				--card-top-line: linear-gradient(90deg, var(--accent) 0%, var(--accent-2) 100%);
				--card-shadow: 0 32px 80px rgba(15,17,40,0.13), 0 8px 24px rgba(15,17,40,0.08);
				--card-shadow-2: 0 0 0 1px rgba(255,255,255,0.6) inset;
				--panel-bg: rgba(255,255,255,0.42);
				--panel-border: rgba(91,110,245,0.13);
				--ok-bg: rgba(91,110,245,0.08);
				--ok-border: rgba(91,110,245,0.22);
				--ok-text: var(--accent);
				--btn-bg: rgba(255,255,255,0.55);
				--btn-border: rgba(91,110,245,0.22);
				--btn-hover: rgba(255,255,255,0.80);
				--btn-active: rgba(91,110,245,0.12);
				--input-bg: rgba(255,255,255,0.72);
				--input-border: rgba(91,110,245,0.2);
				--inset: inset 0 1px 0 rgba(255,255,255,0.7);
				--radius-lg: 26px;
				--radius-md: 14px;
				--blur: 22px;
				/* fluid sizing tokens */
				--card-max: 1060px;
				--card-pad: 24px;
				--base-font: 15px;
				--textarea-h: 220px;
				--wrap-pad-x: 14px;
				/* animation tokens */
				--ease: cubic-bezier(0.25, 1, 0.5, 1);
				--ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
				--t-fast: 140ms;
				--t-mid: 260ms;
				--t-slow: 420ms;
			}

			/* â‰¥ 768 px â€“ tablet */
			@media (min-width: 768px) {
				:root {
					--card-max: 1200px;
					--card-pad: 32px;
					--base-font: 16px;
					--textarea-h: 260px;
					--wrap-pad-x: 24px;
					--radius-lg: 26px;
					--radius-md: 16px;
					--blur: 22px;
				}
			}

			/* â‰¥ 1200 px â€“ desktop */
			@media (min-width: 1200px) {
				:root {
					--card-max: 1420px;
					--card-pad: 40px;
					--base-font: 17px;
					--textarea-h: 320px;
					--wrap-pad-x: 40px;
					--radius-lg: 30px;
					--radius-md: 18px;
					--blur: 26px;
				}
			}

			/* â‰¥ 1600 px â€“ wide / ultrawide */
			@media (min-width: 1600px) {
				:root {
					--card-max: 1680px;
					--card-pad: 48px;
					--base-font: 18px;
					--textarea-h: 380px;
					--wrap-pad-x: 60px;
					--radius-lg: 34px;
					--radius-md: 20px;
					--blur: 30px;
				}
			}

			/* â”€â”€ Dark palette â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
			@media (prefers-color-scheme: dark) {
				:root {
					--bg: #0b0d14;
					--text: #e8eaf6;
					--muted: #7a84a8;
					--accent: #818cf8;
					--accent-2: #c084fc;
					--accent-glow: rgba(129,140,248,0.25);
					--accent-glow-2: rgba(192,132,252,0.16);
					--ring: rgba(129,140,248,0.40);
					--card-bg: rgba(17,19,35,0.78);
					--card-border: rgba(129,140,248,0.18);
					--card-shadow: 0 32px 80px rgba(0,0,0,0.5), 0 8px 24px rgba(0,0,0,0.3);
					--card-shadow-2: 0 0 0 1px rgba(255,255,255,0.07) inset;
					--panel-bg: rgba(255,255,255,0.04);
					--panel-border: rgba(129,140,248,0.16);
					--ok-bg: rgba(129,140,248,0.12);
					--ok-border: rgba(129,140,248,0.30);
					--ok-text: var(--accent);
					--btn-bg: rgba(255,255,255,0.06);
					--btn-border: rgba(129,140,248,0.24);
					--btn-hover: rgba(255,255,255,0.10);
					--btn-active: rgba(129,140,248,0.18);
					--input-bg: rgba(255,255,255,0.06);
					--input-border: rgba(129,140,248,0.22);
					--inset: inset 0 1px 0 rgba(255,255,255,0.08);
				}
			}

			* {
				box-sizing: border-box;
			}

			/* Ensure [hidden] always wins, even against display:grid/.wrap etc. */
			[hidden] { display: none !important; }

			body {
				margin: 0;
				font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
				font-size: var(--base-font);
				background:
					/* Top-left bloom â€“ primary accent */
					radial-gradient(ellipse 70% 60% at 5% 0%,   color-mix(in srgb, var(--accent)   62%, transparent), transparent),
					/* Top-right bloom â€“ secondary accent */
					radial-gradient(ellipse 55% 50% at 95% 5%,  color-mix(in srgb, var(--accent-2)  48%, transparent), transparent),
					/* Centre soft haze */
					radial-gradient(ellipse 80% 55% at 50% 46%, color-mix(in srgb, var(--accent)   18%, transparent), transparent),
					/* Bottom anchor */
					radial-gradient(ellipse 90% 55% at 25% 100%,color-mix(in srgb, var(--accent-2)  28%, transparent), transparent),
					/* Diagonal shimmer */
					linear-gradient(135deg,
						color-mix(in srgb, var(--accent) 12%, transparent) 0%,
						transparent 45%,
						color-mix(in srgb, var(--accent-2) 10%, transparent) 100%),
					var(--bg);
				color: var(--text);
				min-height: 100vh;
			}

			/* Grain overlay */
			body::before {
				content: '';
				position: fixed;
				inset: 0;
				pointer-events: none;
				z-index: 0;
				opacity: 0.045;
				background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23n)'/%3E%3C/svg%3E");
				background-size: 200px 200px;
			}
			/* Slow-moving aurora shimmer */
			body::after {
				content: '';
				position: fixed;
				inset: -20%;
				pointer-events: none;
				z-index: 0;
				background:
					radial-gradient(ellipse 60% 40% at 30% 30%, color-mix(in srgb, var(--accent) 10%, transparent), transparent 70%),
					radial-gradient(ellipse 50% 35% at 75% 70%, color-mix(in srgb, var(--accent-2) 9%, transparent), transparent 70%);
				animation: aurora-drift 18s ease-in-out infinite alternate;
				will-change: transform;
			}
			@keyframes aurora-drift {
				0%   { transform: translate(0, 0)    scale(1); }
				33%  { transform: translate(3%, -4%) scale(1.04); }
				66%  { transform: translate(-4%, 3%) scale(0.97); }
				100% { transform: translate(2%, 5%)  scale(1.02); }
			}

			/* Make sure page content sits above the grain */
			.wrap, header, main {
				position: relative;
				z-index: 1;
			}

			.wrap {
				min-height: 100vh;
				display: grid;
				place-items: center;
				padding: 30px var(--wrap-pad-x);
			}

			/* App is top-aligned so the card never jumps when tab content changes height. */
			#app.wrap {
				place-items: start center;
				padding-top: 32px;
				padding-bottom: 48px;
				align-items: start;
			}

			/* Login stays visually centered, but auth tab resizes grow/shrink downward (top stays fixed). */
			#login-screen.wrap {
				place-items: start center;
				padding-top: var(--login-pad-top, 30px);
				padding-bottom: 30px;
			}

			.card {
				width: min(var(--card-max), 100%);
				background: var(--card-bg);
				border: 1px solid var(--card-border);
				border-radius: var(--radius-lg);
				padding: var(--card-pad);
				overflow: hidden;
				backface-visibility: hidden;
				-webkit-backface-visibility: hidden;
				box-shadow: var(--card-shadow), var(--card-shadow-2);
				backdrop-filter: blur(var(--blur)) saturate(160%);
				-webkit-backdrop-filter: blur(var(--blur)) saturate(160%);
				animation: card-enter 0.6s var(--ease) both;
				position: relative;
			}
			/* Coloured accent stripe at the top of the card */
			.card::before {
				content: '';
				position: absolute;
				top: 0; left: 0; right: 0;
				height: 3px;
				background: var(--card-top-line);
				border-radius: var(--radius-lg) var(--radius-lg) 0 0;
				opacity: 0.85;
			}

			@keyframes card-enter {
				from { opacity: 0; transform: translateY(18px) scale(0.985); }
				to   { opacity: 1; transform: translateY(0)   scale(1); }
			}

			#app .card {
				transform: none;
			}

			@supports not ((backdrop-filter: blur(1px)) or (-webkit-backdrop-filter: blur(1px))) {
				.card {
					background: color-mix(in srgb, Canvas 94%, CanvasText);
				}
			}

			header {
				display: flex;
				align-items: center;
				gap: 14px;
			}

			.header-actions {
				margin-left: auto;
			}

			.mark {
				width: 46px;
				height: 46px;
				border-radius: 14px;
				border: 1.5px solid var(--ring);
				display: grid;
				place-items: center;
				font-size: 1.15rem;
				font-weight: 800;
				letter-spacing: -0.03em;
				user-select: none;
				background: linear-gradient(135deg, var(--accent-glow) 0%, var(--accent-glow-2) 100%);
				box-shadow: var(--inset), 0 0 0 0 var(--accent-glow);
				color: var(--accent);
				transition: transform var(--t-mid) var(--ease-spring), box-shadow var(--t-mid) var(--ease);
			}
			.mark:hover {
				transform: scale(1.1) rotate(-4deg);
				box-shadow: var(--inset), 0 6px 22px var(--accent-glow);
			}

			h1 {
				font-size: clamp(1.5rem, 1.1rem + 2vw, 2.2rem);
				line-height: 1.12;
				margin: 0;
				letter-spacing: -0.04em;
				background: linear-gradient(110deg, var(--text) 50%, var(--accent) 130%);
				-webkit-background-clip: text;
				-webkit-text-fill-color: transparent;
				background-clip: text;
			}

			.subtitle {
				margin: 5px 0 0;
				color: var(--muted);
				font-size: 0.92rem;
				letter-spacing: 0.01em;
			}

			.row {
				margin-top: 16px;
				display: flex;
				align-items: center;
				justify-content: space-between;
				gap: 12px;
				flex-wrap: wrap;
			}

			.auth {
				display: inline-flex;
				align-items: center;
				gap: 10px;
				color: var(--muted);
				font-size: 0.95rem;
			}

			#save-status {
				padding: 3px 11px;
				border-radius: 999px;
				border: 1px solid var(--ok-border);
				color: var(--ok-text);
				background: var(--ok-bg);
				font-size: 0.82rem;
				font-weight: 700;
				letter-spacing: 0.02em;
				text-transform: uppercase;
				animation: badge-pop var(--t-mid) var(--ease-spring) both;
			}

			@keyframes badge-pop {
				from { opacity: 0; transform: scale(0.82); }
				to   { opacity: 1; transform: scale(1); }
			}

			.tabs {
				margin-top: 16px;
				display: inline-flex;
				gap: 4px;
				padding: 4px;
				border-radius: 999px;
				border: 1px solid var(--card-border);
				background: rgba(0,0,0,0.05);
				backdrop-filter: blur(calc(var(--blur) * 0.5)) saturate(150%);
				-webkit-backdrop-filter: blur(calc(var(--blur) * 0.5)) saturate(150%);
				box-shadow: inset 0 1px 0 rgba(255,255,255,0.15), 0 1px 4px rgba(0,0,0,0.06);
			}

			.tab {
				appearance: none;
				border: 1px solid transparent;
				background: transparent;
				color: var(--muted);
				padding: 7px 14px;
				border-radius: 999px;
				font-size: 0.88rem;
				font-weight: 600;
				letter-spacing: 0.01em;
				cursor: pointer;
				transition:
					color var(--t-fast) var(--ease),
					background var(--t-fast) var(--ease),
					border-color var(--t-fast) var(--ease),
					box-shadow var(--t-mid) var(--ease),
					transform var(--t-mid) var(--ease-spring);
			}
			.tab:hover:not([aria-selected='true']) {
				color: var(--text);
				background: rgba(255,255,255,0.18);
			}
			.tab:active {
				transform: scale(0.93);
			}

			.tab[aria-selected='true'] {
				color: var(--accent);
				background: var(--card-bg);
				border-color: var(--ring);
				box-shadow: var(--inset), 0 2px 10px var(--accent-glow);
				animation: tab-select var(--t-mid) var(--ease-spring) both;
			}

			@keyframes tab-select {
				from { transform: scale(0.91); opacity: 0.7; }
				to   { transform: scale(1);    opacity: 1; }
			}

			.btn {
				appearance: none;
				border: 1px solid var(--btn-border);
				background: var(--btn-bg);
				color: var(--text);
				padding: 10px 16px;
				border-radius: var(--radius-md);
				font-size: 0.9rem;
				font-weight: 600;
				letter-spacing: 0.01em;
				cursor: pointer;
				box-shadow: var(--inset), 0 1px 3px rgba(0,0,0,0.07);
				transition:
					background var(--t-fast) var(--ease),
					border-color var(--t-fast) var(--ease),
					box-shadow var(--t-mid) var(--ease),
					transform var(--t-mid) var(--ease-spring),
					opacity var(--t-fast) var(--ease);
			}

			.btn:hover {
				background: var(--btn-hover);
				border-color: var(--ring);
				box-shadow: var(--inset), 0 4px 16px var(--accent-glow);
				transform: translateY(-1px);
			}

			.btn:active {
				background: var(--btn-active);
				transform: scale(0.95) translateY(0);
				box-shadow: var(--inset);
			}

			.btn:disabled {
				opacity: 0.45;
				cursor: not-allowed;
				transform: none;
			}

			/* Accent/primary button variant */
			.btn-accent {
				background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);
				border-color: transparent;
				color: #fff;
				box-shadow: var(--inset), 0 4px 18px var(--accent-glow);
			}
			.btn-accent:hover {
				background: linear-gradient(135deg, color-mix(in srgb, var(--accent) 85%, #fff) 0%, color-mix(in srgb, var(--accent-2) 85%, #fff) 100%);
				border-color: transparent;
				box-shadow: var(--inset), 0 6px 24px var(--accent-glow);
			}
			.btn-accent:active {
				background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);
			}

			.input,
			textarea {
				width: 100%;
				padding: 10px 13px;
				border-radius: var(--radius-md);
				border: 1.5px solid var(--input-border);
				background: var(--input-bg);
				color: var(--text);
				font: inherit;
				box-shadow: var(--inset), inset 0 1px 3px rgba(0,0,0,0.04);
				transition:
					border-color var(--t-fast) var(--ease),
					box-shadow var(--t-mid) var(--ease),
					background var(--t-fast) var(--ease);
			}
			.input:focus,
			textarea:focus {
				outline: none;
				border-color: var(--accent);
				box-shadow: var(--inset), 0 0 0 3.5px var(--accent-glow);
			}
			.input:hover:not(:focus),
			textarea:hover:not(:focus) {
				border-color: color-mix(in srgb, var(--accent) 45%, var(--input-border));
			}

			textarea {
				min-height: var(--textarea-h);
				max-width: 100%;
				display: block;
				resize: vertical;
			}

			.fields {
				margin-top: 16px;
				display: grid;
				gap: 12px;
			}

			.field label {
				display: block;
				margin-bottom: 7px;
				font-size: 0.82rem;
				font-weight: 700;
				letter-spacing: 0.05em;
				text-transform: uppercase;
				color: var(--muted);
			}

			.actions {
				margin-top: 14px;
				display: flex;
				gap: 10px;
				flex-wrap: wrap;
			}

			.pwrow {
				display: flex;
				gap: 10px;
				align-items: center;
			}

			.pwrow .input {
				flex: 1;
			}

			.btn.btn-small {
				padding: 8px 10px;
				border-radius: 12px;
				white-space: nowrap;
			}

			.notes-label {
				display: block;
				margin-top: 14px;
				font-weight: 700;
			}

			/* â”€â”€ Files tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
			.upload-zone {
				margin-top: 14px;
				border: 2px dashed var(--panel-border);
				border-radius: var(--radius-md);
				padding: 28px 16px;
				text-align: center;
				cursor: pointer;
				transition: border-color var(--t-mid) var(--ease), background var(--t-mid) var(--ease), box-shadow var(--t-mid) var(--ease);
			}
			.upload-zone:hover, .upload-zone.drag-over {
				border-color: var(--accent);
				background: var(--accent-glow);
				box-shadow: 0 0 0 4px var(--accent-glow);
			}
			.upload-zone input[type="file"] {
				display: none;
			}
			.upload-zone-label {
				display: block;
				font-weight: 600;
				margin-bottom: 4px;
			}
			.upload-zone-sub {
				font-size: 0.88rem;
				color: var(--muted);
			}
			.upload-progress {
				display: none;
				margin-top: 12px;
				height: 4px;
				border-radius: 999px;
				background: var(--panel-border);
				overflow: hidden;
			}
			.upload-progress.visible { display: block; }
			.upload-progress-bar {
				height: 100%;
				width: 0%;
				background: linear-gradient(90deg, var(--accent) 0%, var(--accent-2) 100%);
				border-radius: 999px;
				transition: width 0.3s var(--ease);
			}
			.files-status {
				margin-top: 10px;
				min-height: 1.4em;
				font-size: 0.92rem;
				color: var(--muted);
			}
			.file-list {
				margin-top: 14px;
				display: flex;
				flex-direction: column;
				gap: 6px;
			}
			.file-row {
				display: flex;
				align-items: center;
				gap: 10px;
				padding: 9px 12px;
				border-radius: var(--radius-md);
				background: var(--btn-bg);
				border: 1px solid var(--btn-border);
				word-break: break-all;
				transition: background var(--t-fast) var(--ease), transform var(--t-mid) var(--ease-spring), box-shadow var(--t-fast) var(--ease);
				animation: file-row-in var(--t-slow) var(--ease) both;
			}
			.file-row:hover {
				background: var(--btn-hover);
				transform: translateY(-1px);
				box-shadow: 0 4px 12px color-mix(in srgb, CanvasText 8%, transparent);
			}

			@keyframes file-row-in {
				from { opacity: 0; transform: translateY(6px); }
				to   { opacity: 1; transform: translateY(0); }
			}
			.file-row-name {
				flex: 1;
				font-size: 0.93rem;
				font-weight: 600;
			}
			.file-row-meta {
				font-size: 0.8rem;
				color: var(--muted);
				white-space: nowrap;
			}
			.file-row-actions {
				display: flex;
				gap: 6px;
				flex-shrink: 0;
			}

			/* stagger file rows */
			.file-row:nth-child(1)  { animation-delay:  0ms; }
			.file-row:nth-child(2)  { animation-delay: 40ms; }
			.file-row:nth-child(3)  { animation-delay: 80ms; }
			.file-row:nth-child(4)  { animation-delay:120ms; }
			.file-row:nth-child(5)  { animation-delay:160ms; }
			.file-row:nth-child(n+6){ animation-delay:200ms; }

			#panel-notes .row {
				margin-bottom: 10px;
			}

			#notes {
				margin-top: 8px;
				line-height: 1.35;
			}

			/* â”€â”€ Multi-doc notes layout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
			.notes-layout {
				display: grid;
				grid-template-columns: 220px 1fr;
				gap: 14px;
				margin-top: 14px;
			}
			@media (max-width: 600px) {
				.notes-layout { grid-template-columns: 1fr; }
				.notes-sidebar { max-height: 180px; }
			}

			.notes-sidebar {
				display: flex;
				flex-direction: column;
				gap: 4px;
				overflow-y: auto;
				max-height: 460px;
				padding-right: 2px;
			}
			.notes-sidebar::-webkit-scrollbar { width: 4px; }
			.notes-sidebar::-webkit-scrollbar-thumb { background: var(--panel-border); border-radius: 99px; }

			.doc-item {
				display: flex;
				align-items: center;
				gap: 6px;
				padding: 8px 10px;
				border-radius: var(--radius-md);
				border: 1px solid transparent;
				cursor: pointer;
				background: transparent;
				width: 100%;
				text-align: left;
				transition: background var(--t-fast) var(--ease), border-color var(--t-fast) var(--ease), transform var(--t-mid) var(--ease-spring);
				animation: file-row-in var(--t-slow) var(--ease) both;
			}
			.doc-item:hover {
				background: var(--btn-hover);
				border-color: var(--panel-border);
				transform: translateX(2px);
			}
			.doc-item.active {
				background: var(--ok-bg);
				border-color: var(--accent);
				color: var(--accent);
			}
			.doc-item-name {
				flex: 1;
				font-size: 0.88rem;
				font-weight: 600;
				overflow: hidden;
				text-overflow: ellipsis;
				white-space: nowrap;
			}
			.doc-item-date {
				font-size: 0.73rem;
				color: var(--muted);
				white-space: nowrap;
			}

			.notes-editor-col {
				display: flex;
				flex-direction: column;
				gap: 8px;
			}
			.notes-editor-toolbar {
				display: flex;
				gap: 8px;
				align-items: center;
				flex-wrap: wrap;
			}
			.notes-title-input {
				flex: 1;
				min-width: 120px;
				font-weight: 700;
				font-size: 1rem;
			}
			#notes {
				margin-top: 0;
				flex: 1;
			}

			.panel {
				margin-top: 20px;
				padding: 18px;
				border-radius: calc(var(--radius-lg) - 4px);
				background: var(--panel-bg);
				border: 1px solid var(--panel-border);
				box-shadow: var(--inset), 0 2px 12px rgba(0,0,0,0.04);
				backdrop-filter: blur(calc(var(--blur) * 0.7)) saturate(150%);
				-webkit-backdrop-filter: blur(calc(var(--blur) * 0.7)) saturate(150%);
				animation: panel-in var(--t-slow) var(--ease) both;
			}

			@keyframes panel-in {
				from { opacity: 0; transform: translateY(10px) scale(0.99); }
				to   { opacity: 1; transform: translateY(0)   scale(1); }
			}

			.status {
				display: inline-flex;
				align-items: center;
				gap: 8px;
				margin: 18px 0 0;
				padding: 9px 16px;
				border-radius: 999px;
				background: var(--ok-bg);
				border: 1px solid var(--ok-border);
				color: var(--ok-text);
				font-size: 0.9rem;
				font-weight: 700;
				letter-spacing: 0.01em;
				width: fit-content;
				box-shadow: 0 2px 12px var(--accent-glow);
				backdrop-filter: blur(calc(var(--blur) * 0.6)) saturate(150%);
				-webkit-backdrop-filter: blur(calc(var(--blur) * 0.6)) saturate(150%);
			}

			.dot {
				width: 8px;
				height: 8px;
				border-radius: 999px;
				background: var(--accent);
				box-shadow: 0 0 0 0 var(--accent-glow);
				animation: dot-pulse 2.4s var(--ease) infinite;
			}

			@keyframes dot-pulse {
				0%   { opacity: 1;   transform: scale(1);    box-shadow: 0 0 0 0   var(--accent-glow); }
				50%  { opacity: 0.7; transform: scale(0.8);  box-shadow: 0 0 0 5px transparent; }
				100% { opacity: 1;   transform: scale(1);    box-shadow: 0 0 0 0   var(--accent-glow); }
			}

			.meta {
				margin-top: 18px;
				padding-top: 16px;
				border-top: 1px solid color-mix(in srgb, CanvasText 10%, transparent);
				display: flex;
				flex-wrap: wrap;
				gap: 10px 16px;
				color: var(--muted);
				font-size: 0.95rem;
			}

			a:focus-visible,
			.tab:focus-visible,
			.btn:focus-visible,
			.input:focus-visible,
			textarea:focus-visible {
				outline: 2.5px solid var(--accent);
				outline-offset: 3px;
				border-radius: 12px;
			}

			a {
				color: var(--accent);
				text-underline-offset: 4px;
				transition: color var(--t-fast) var(--ease), opacity var(--t-fast) var(--ease);
			}
			a:hover { opacity: 0.78; }

			.hint {
				margin: 10px 0 0;
				color: var(--muted);
				font-size: 0.95rem;
			}

			/* â”€â”€ Customization settings â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
			.settings-section {
				margin-top: 22px;
				padding-top: 18px;
				border-top: 1px solid var(--panel-border);
			}
			.settings-section:first-child { margin-top: 0; padding-top: 0; border-top: none; }

			.settings-section-title {
				font-size: 0.78rem;
				font-weight: 800;
				letter-spacing: 0.08em;
				text-transform: uppercase;
				color: var(--muted);
				margin: 0 0 12px;
			}

			/* Colour swatches */
			.swatch-row {
				display: flex;
				gap: 10px;
				flex-wrap: wrap;
			}
			.swatch {
				width: 32px;
				height: 32px;
				border-radius: 50%;
				border: 2.5px solid transparent;
				cursor: pointer;
				transition: transform var(--t-mid) var(--ease-spring), box-shadow var(--t-mid) var(--ease), border-color var(--t-fast) var(--ease);
				outline: none;
				box-shadow: 0 2px 8px rgba(0,0,0,0.15);
			}
			.swatch:hover {
				transform: scale(1.15);
				box-shadow: 0 4px 16px rgba(0,0,0,0.22);
			}
			.swatch.active {
				border-color: var(--text);
				transform: scale(1.18);
				box-shadow: 0 0 0 3px var(--card-bg), 0 0 0 5px var(--text), 0 4px 16px rgba(0,0,0,0.18);
			}

			/* Option chips (font size, width, bg style) */
			.chip-row {
				display: flex;
				gap: 8px;
				flex-wrap: wrap;
			}
			.chip {
				appearance: none;
				border: 1.5px solid var(--btn-border);
				background: var(--btn-bg);
				color: var(--muted);
				padding: 6px 14px;
				border-radius: 999px;
				font-size: 0.85rem;
				font-weight: 600;
				cursor: pointer;
				transition:
					background var(--t-fast) var(--ease),
					border-color var(--t-fast) var(--ease),
					color var(--t-fast) var(--ease),
					box-shadow var(--t-mid) var(--ease),
					transform var(--t-mid) var(--ease-spring);
			}
			.chip:hover {
				border-color: var(--ring);
				color: var(--text);
				background: var(--btn-hover);
			}
			.chip:active { transform: scale(0.94); }
			.chip.active {
				background: var(--accent-glow);
				border-color: var(--accent);
				color: var(--accent);
				box-shadow: 0 0 0 3px var(--accent-glow);
			}

			.prefs-save-row {
				margin-top: 18px;
				display: flex;
				align-items: center;
				gap: 12px;
			}
			#prefs-status {
				font-size: 0.85rem;
				color: var(--muted);
			}

			/* â”€â”€ end customization â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */

			@media (prefers-reduced-motion: reduce) {
				* {
					scroll-behavior: auto !important;
					transition: none !important;
					animation: none !important;
				}
				body::after {
					animation: none !important;
				}
			}
		</style>
	</head>

	<body>
		<div class="wrap" id="login-screen">
			<main class="card">
				<header>
					<div class="mark" aria-hidden="true">e</div>
					<div>
						<h1>ectl.me</h1>
						<p class="subtitle">Log in to continue.</p>
					</div>
				</header>

				<div class="row" style="margin-bottom: 0">
					<div class="auth">
						<span id="login-status">Signed out</span>
					</div>
					<div>
						<button class="btn btn-small" id="btn-toggle-login-debug" type="button" aria-expanded="false">
							Show status
						</button>
					</div>
				</div>

				<div class="tabs" role="tablist" aria-label="Auth tabs">
					<button class="tab" id="auth-tab-login" type="button" role="tab" aria-controls="auth-panel-login" aria-selected="true">
						Log in
					</button>
					<button class="tab" id="auth-tab-signup" type="button" role="tab" aria-controls="auth-panel-signup" aria-selected="false">
						Create account
					</button>
				</div>

				<section class="panel" id="auth-panel-login" role="tabpanel" aria-labelledby="auth-tab-login">
					<div class="fields">
						<div class="field">
							<label for="login-identifier">Username or email</label>
							<input
								class="input"
								id="login-identifier"
								name="username"
								type="text"
								autocomplete="username"
								placeholder="yourname or you@example.com"
							/>
						</div>
						<div class="field">
							<label for="login-password">Password</label>
							<div class="pwrow">
								<input class="input" id="login-password" name="password" type="password" autocomplete="current-password" placeholder="your password" />
								<button class="btn btn-small" id="btn-toggle-login-password" type="button" aria-pressed="false">
									Show
								</button>
							</div>
						</div>
					</div>

					<div class="actions">
						<button class="btn btn-accent" id="btn-login" type="button">Log in</button>
					</div>
					<p class="hint">You can log in with either username or email.</p>
				</section>

				<section class="panel" id="auth-panel-signup" role="tabpanel" aria-labelledby="auth-tab-signup" hidden>
					<div class="fields">
						<div class="field">
							<label for="signup-username">Username</label>
							<input class="input" id="signup-username" name="username" type="text" autocomplete="username" />
						</div>
						<div class="field">
							<label for="signup-email">Email</label>
							<input class="input" id="signup-email" name="email" type="email" autocomplete="email" />
						</div>
						<div class="field">
							<label for="signup-password">Password</label>
							<div class="pwrow">
								<input class="input" id="signup-password" name="password" type="password" autocomplete="new-password" />
								<button class="btn btn-small" id="btn-toggle-signup-password" type="button" aria-pressed="false">Show</button>
							</div>
						</div>
					</div>

					<div class="actions">
						<button class="btn btn-accent" id="btn-signup" type="button">Create account</button>
					</div>
					<p class="hint">Create account requires username + email.</p>
				</section>

				<p class="hint" id="login-debug" hidden></p>
			</main>
		</div>

		<div class="wrap" id="app" hidden>
			<main class="card">
				<header>
					<div class="mark" aria-hidden="true">e</div>
					<div>
						<h1>ectl.me</h1>
						<p class="subtitle">A small static site, deployed with Vercel.</p>

						<div class="tabs" role="tablist" aria-label="Page tabs">
							<button class="tab" id="tab-home" type="button" role="tab" aria-controls="panel-home" aria-selected="true">Home</button>
							<button class="tab" id="tab-notes" type="button" role="tab" aria-controls="panel-notes" aria-selected="false">Notes</button>
							<button class="tab" id="tab-settings" type="button" role="tab" aria-controls="panel-settings" aria-selected="false">Settings</button>
							<button class="tab" id="tab-files" type="button" role="tab" aria-controls="panel-files" aria-selected="false">Files</button>
						</div>
					</div>
						<div class="header-actions">
							<button class="btn" id="btn-signout" type="button" hidden>Sign out</button>
						</div>
				</header>

				<section class="panel" id="panel-home" role="tabpanel" aria-labelledby="tab-home">
					<div class="status" role="status" aria-live="polite">
						<span class="dot" aria-hidden="true"></span>
						<span>It works</span>
					</div>

					<div class="meta">
						<span>Update this page by editing <code>index.html</code>.</span>
						<span>Local preview: <a href="/" rel="nofollow">/</a></span>
					</div>
				</section>

				<section class="panel" id="panel-notes" role="tabpanel" aria-labelledby="tab-notes" hidden>
					<div class="row" style="margin-bottom:0">
						<div class="auth">
							<span id="auth-status">Checking sign-inâ€¦</span>
							<span id="save-status" hidden>Saved</span>
						</div>
						<div style="display:flex;gap:8px;align-items:center">
							<button class="btn btn-small btn-accent" id="btn-new-doc" type="button" title="New document">+ New</button>
							<button class="btn btn-small" id="btn-dl-all" type="button" title="Download all as zip">â¤“ All</button>
						</div>
					</div>

					<div class="notes-layout">
						<!-- Sidebar: document list -->
						<div class="notes-sidebar" id="doc-list" role="list" aria-label="Documents"></div>

						<!-- Editor -->
						<div class="notes-editor-col" id="notes-editor-col">
							<div class="notes-editor-toolbar">
								<input class="input notes-title-input" id="doc-title" type="text" placeholder="Document title" />
								<button class="btn btn-small" id="btn-rename-doc" type="button">Rename</button>
								<button class="btn btn-small" id="btn-dl-doc" type="button" title="Download as .txt">â¤“ .txt</button>
								<button class="btn btn-small" id="btn-delete-doc" type="button" title="Delete document">ðŸ—‘</button>
							</div>
							<textarea id="notes" name="notes" placeholder="Sign in to write notes" disabled></textarea>
							<p class="hint" id="notes-hint">Your notes sync to the cloud.</p>
						</div>
					</div>
				</section>

					<section class="panel" id="panel-settings" role="tabpanel" aria-labelledby="tab-settings" hidden>

					<!-- Account -->
					<div class="settings-section">
						<p class="settings-section-title">Account</p>
						<p class="hint" id="acct-current" style="margin:0 0 14px">Signed in</p>
						<div class="fields">
							<div class="field">
								<label for="acct-username">New username</label>
								<input class="input" id="acct-username" name="acct-username" type="text" autocomplete="username" />
							</div>
							<div class="actions">
								<button class="btn" id="btn-update-username" type="button">Update username</button>
							</div>
							<div class="field">
								<label for="acct-password">New password</label>
								<div class="pwrow">
									<input class="input" id="acct-password" name="acct-password" type="password" autocomplete="new-password" />
									<button class="btn btn-small" id="btn-toggle-acct-password" type="button" aria-pressed="false">Show</button>
								</div>
							</div>
							<div class="actions">
								<button class="btn" id="btn-update-password" type="button">Update password</button>
								<button class="btn" id="btn-delete-account" type="button">Delete account</button>
							</div>
						</div>
						<p class="hint" id="acct-status"></p>
					</div>

					<!-- Customization -->
					<div class="settings-section">
						<p class="settings-section-title">Customization</p>

						<!-- Accent colour -->
						<div class="field" style="margin-bottom:18px">
							<label style="margin-bottom:10px">Accent colour</label>
							<div class="swatch-row" id="swatch-row" role="radiogroup" aria-label="Accent colour"></div>
						</div>

						<!-- Font size -->
						<div class="field" style="margin-bottom:18px">
							<label style="margin-bottom:10px">Font size</label>
							<div class="chip-row" id="chips-fontsize" role="radiogroup" aria-label="Font size">
								<button class="chip" data-val="small"  type="button">Small</button>
								<button class="chip" data-val="medium" type="button">Medium</button>
								<button class="chip" data-val="large"  type="button">Large</button>
							</div>
						</div>

						<!-- Card width -->
						<div class="field" style="margin-bottom:18px">
							<label style="margin-bottom:10px">Card width</label>
							<div class="chip-row" id="chips-cardwidth" role="radiogroup" aria-label="Card width">
								<button class="chip" data-val="compact" type="button">Compact</button>
								<button class="chip" data-val="regular" type="button">Regular</button>
								<button class="chip" data-val="wide"    type="button">Wide</button>
							</div>
						</div>

						<!-- Background style -->
						<div class="field">
							<label style="margin-bottom:10px">Background</label>
							<div class="chip-row" id="chips-bgstyle" role="radiogroup" aria-label="Background style">
								<button class="chip" data-val="aurora"  type="button">Aurora</button>
								<button class="chip" data-val="subtle"  type="button">Subtle</button>
								<button class="chip" data-val="minimal" type="button">Minimal</button>
							</div>
						</div>

						<div class="prefs-save-row">
							<button class="btn btn-accent" id="btn-save-prefs" type="button">Save preferences</button>
							<span id="prefs-status"></span>
						</div>
					</div>

				</section>

					<section class="panel" id="panel-files" role="tabpanel" aria-labelledby="tab-files" hidden>
						<p class="subtitle" style="margin-top: 4px; margin-bottom: 2px">Files</p>
						<div class="upload-zone" id="files-upload-zone" role="button" tabindex="0" aria-label="Upload files">
							<input type="file" id="files-input" multiple />
							<span class="upload-zone-label">Click or drag files here to upload</span>
							<span class="upload-zone-sub">Files are private to your account</span>
						</div>
						<div class="upload-progress" id="files-upload-progress">
							<div class="upload-progress-bar" id="files-upload-bar"></div>
						</div>
						<p class="files-status" id="files-status" aria-live="polite"></p>
						<div class="file-list" id="file-list"></div>
					</section>
			</main>
		</div>

		<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
		<script>
			const SUPABASE_URL = 'https://oxgaltttggmxukslgjxn.supabase.co';
			const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im94Z2FsdHR0Z2dteHVrc2xnanhuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzIxOTA0NDYsImV4cCI6MjA4Nzc2NjQ0Nn0.Q8X_MQs_nFuhtGpY4K-KzvsaXT419Sc2Vx6slXi6Rdw';
			const USERNAME_MIN_LEN = 3;
			const USERNAME_MAX_LEN = 24;
			const AUTH_TIMEOUT_MS = 15000;
			const BUILD_STAMP = '2026-02-27';

			const loginScreenEl = document.getElementById('login-screen');
			const appEl = document.getElementById('app');
			const loginStatusEl = document.getElementById('login-status');
			const loginDebugEl = document.getElementById('login-debug');
			const loginDebugToggleBtn = document.getElementById('btn-toggle-login-debug');
			const authStatusEl = document.getElementById('auth-status');
			const saveStatusEl = document.getElementById('save-status');
			const signOutBtn = document.getElementById('btn-signout');
			const loginIdentifierEl = document.getElementById('login-identifier');
			const loginPasswordEl = document.getElementById('login-password');
			const toggleLoginPasswordBtn = document.getElementById('btn-toggle-login-password');
			const signupUsernameEl = document.getElementById('signup-username');
			const signupEmailEl = document.getElementById('signup-email');
			const signupPasswordEl = document.getElementById('signup-password');
			const toggleSignupPasswordBtn = document.getElementById('btn-toggle-signup-password');
			const loginBtn = document.getElementById('btn-login');
			const signupBtn = document.getElementById('btn-signup');
			const notesEl = document.getElementById('notes');
			const notesHintEl = document.getElementById('notes-hint');
			const acctCurrentEl = document.getElementById('acct-current');
			const acctStatusEl = document.getElementById('acct-status');
			const acctUsernameEl = document.getElementById('acct-username');
			const acctPasswordEl = document.getElementById('acct-password');
			const toggleAcctPasswordBtn = document.getElementById('btn-toggle-acct-password');
			const updateUsernameBtn = document.getElementById('btn-update-username');
			const updatePasswordBtn = document.getElementById('btn-update-password');
			const deleteAccountBtn = document.getElementById('btn-delete-account');

			const tabs = [
				{ tab: document.getElementById('tab-home'), panel: document.getElementById('panel-home') },
				{ tab: document.getElementById('tab-notes'), panel: document.getElementById('panel-notes') },
				{ tab: document.getElementById('tab-settings'), panel: document.getElementById('panel-settings') },
				{ tab: document.getElementById('tab-files'), panel: document.getElementById('panel-files') },
			];

			const authTabs = [
				{ tab: document.getElementById('auth-tab-login'), panel: document.getElementById('auth-panel-login') },
				{ tab: document.getElementById('auth-tab-signup'), panel: document.getElementById('auth-panel-signup') },
			];

			let inApp = false;
			let loginDebugVisible = false;
			const prefersReducedMotion = window.matchMedia?.('(prefers-reduced-motion: reduce)')?.matches;

			function setLoginStatusText(message) {
				if (!loginStatusEl) return;
				loginStatusEl.textContent = message ? String(message) : '';
			}

			function setLoginDebugText(message) {
				if (!loginDebugEl) return;
				const msg = String(message || '').trim();
				loginDebugEl.textContent = msg ? `${msg} (build ${BUILD_STAMP})` : `build ${BUILD_STAMP}`;
			}

			function setLoginDebugVisible(visible) {
				loginDebugVisible = !!visible;
				if (loginDebugEl) loginDebugEl.hidden = !loginDebugVisible;
				if (loginDebugToggleBtn) {
					loginDebugToggleBtn.textContent = loginDebugVisible ? 'Hide status' : 'Show status';
					loginDebugToggleBtn.setAttribute('aria-expanded', String(loginDebugVisible));
				}
			}

			if (loginDebugToggleBtn) {
				loginDebugToggleBtn.addEventListener('click', () => {
					setLoginDebugVisible(!loginDebugVisible);
				});
			}

			setLoginDebugVisible(false);

			function setSaveStatus(text) {
				if (!saveStatusEl) return;
				if (!text) {
					saveStatusEl.hidden = true;
					saveStatusEl.textContent = '';
					return;
				}
				saveStatusEl.hidden = false;
				saveStatusEl.textContent = text;
			}

			function setButtonsDisabled(disabled) {
				if (loginBtn) loginBtn.disabled = disabled;
				if (signupBtn) signupBtn.disabled = disabled;
				if (loginIdentifierEl) loginIdentifierEl.disabled = disabled;
				if (loginPasswordEl) loginPasswordEl.disabled = disabled;
				if (signupUsernameEl) signupUsernameEl.disabled = disabled;
				if (signupEmailEl) signupEmailEl.disabled = disabled;
				if (signupPasswordEl) signupPasswordEl.disabled = disabled;
			}

			function setAccountStatus(text) {
				if (!acctStatusEl) return;
				acctStatusEl.textContent = String(text || '');
			}

			function showLogin(message) {
				inApp = false;
				if (loginScreenEl) loginScreenEl.hidden = false;
				if (appEl) appEl.hidden = true;
				if (loginScreenEl) loginScreenEl.style.display = '';
				if (appEl) appEl.style.display = 'none';
				setLoginStatusText(message);
				setLoginDebugVisible(false);
				if (authStatusEl) authStatusEl.textContent = 'Signed out';
				if (signOutBtn) signOutBtn.hidden = true;
				if (acctCurrentEl) acctCurrentEl.textContent = 'Signed in';
				if (acctUsernameEl) acctUsernameEl.value = '';
				if (acctPasswordEl) acctPasswordEl.value = '';
				setAccountStatus('');
				if (notesEl) {
					notesEl.disabled = true;
					notesEl.placeholder = 'Sign in to write notes';
					notesEl.value = '';
				}
				if (notesHintEl) notesHintEl.textContent = 'Your notes sync to the cloud.';
				setSaveStatus('');
				recenterLoginCard();
			}

			function showApp(displayName) {
				inApp = true;
				if (loginScreenEl) loginScreenEl.hidden = true;
				if (appEl) appEl.hidden = false;
				if (loginScreenEl) loginScreenEl.style.display = 'none';
				if (appEl) appEl.style.display = '';
				if (authStatusEl) authStatusEl.textContent = `Signed in: ${displayName} (build ${BUILD_STAMP})`;
				if (signOutBtn) signOutBtn.hidden = false;
				if (notesEl) {
					notesEl.disabled = false;
					notesEl.placeholder = 'Write quick notes hereâ€¦';
				}
				if (notesHintEl) notesHintEl.textContent = 'Auto-saves to the cloud.';
			}

			function getAppCard() {
				return document.querySelector('#app .card');
			}

			function getLoginCard() {
				return document.querySelector('#login-screen .card');
			}

			function recenterAppCard() {
				// App is now top-aligned â€” no dynamic centring needed.
			}

			function recenterLoginCard() {
				if (inApp || !loginScreenEl) return;
				window.requestAnimationFrame(() => {
					const card = getLoginCard();
					if (!card) return;
					const viewH = window.innerHeight || 0;
					const cardH = card.getBoundingClientRect().height;
					const top = Math.max(24, Math.round((viewH - cardH) / 2));
					loginScreenEl.style.setProperty('--login-pad-top', `${top}px`);
				});
			}

			function temporarilyDisableBackdrop(card) {
				if (!card) return () => {};
				const prevBackdrop = card.style.backdropFilter;
				const prevWebkitBackdrop = card.style.webkitBackdropFilter;
				card.style.backdropFilter = 'none';
				card.style.webkitBackdropFilter = 'none';
				return () => {
					card.style.backdropFilter = prevBackdrop;
					card.style.webkitBackdropFilter = prevWebkitBackdrop;
				};
			}


			window.addEventListener('resize', () => {
				recenterAppCard();
				recenterLoginCard();
			});

			function setFatalError(err) {
				const message = err?.message || String(err);
				showLogin(`Error: ${message}`);
			}

			window.addEventListener('error', (e) => {
				setFatalError(e?.error || e?.message || 'Unknown error');
			});
			window.addEventListener('unhandledrejection', (e) => {
				setFatalError(e?.reason || 'Unhandled rejection');
			});

			function animateAppLayoutChange(changeFn) {
				const card = getAppCard();
				if (!card || prefersReducedMotion) {
					changeFn();
					return;
				}

				// Cancel any in-flight layout animation to avoid jitter/stacking.
				if (card.__layoutAnimCleanup) {
					try {
						card.__layoutAnimCleanup();
					} catch {
						// ignore
					}
					card.__layoutAnimCleanup = null;
				}

				const firstHeight = card.getBoundingClientRect().height;
				changeFn();
				const lastHeight = card.getBoundingClientRect().height;
				if (Math.abs(firstHeight - lastHeight) < 0.5) return;

				const duration = 720;
				const easing = 'cubic-bezier(0.18, 1, 0.34, 1)';

				const prevWillChange = card.style.willChange;
				const prevOverflow = card.style.overflow;
				const prevTransition = card.style.transition;
				const restoreBackdrop = temporarilyDisableBackdrop(card);

				card.style.willChange = 'height';
				card.style.overflow = 'hidden';
				card.style.transition = 'none';
				card.style.height = `${firstHeight}px`;
				// Force style/layout flush so the next transition starts from the inverted state.
				void card.offsetHeight;

				let finished = false;
				const cleanup = () => {
					if (finished) return;
					finished = true;
					if (card.__layoutAnimOnEnd) {
						card.removeEventListener('transitionend', card.__layoutAnimOnEnd);
						card.__layoutAnimOnEnd = null;
					}
					if (card.__layoutAnimTimer) {
						window.clearTimeout(card.__layoutAnimTimer);
						card.__layoutAnimTimer = null;
					}
					// Freeze at the final pixel height for one frame,
					// then clear back to auto without any transition (Safari-friendly).
					card.style.transition = 'none';
					card.style.height = `${lastHeight}px`;
					void card.offsetHeight;

					window.requestAnimationFrame(() => {
						card.style.willChange = prevWillChange;
						card.style.overflow = prevOverflow;
						card.style.height = '';
						card.style.transition = prevTransition;
						restoreBackdrop();
						card.__layoutAnimCleanup = null;
					});
				};
				card.__layoutAnimCleanup = cleanup;

				const onEnd = (e) => {
					if (e.target !== card) return;
					// Only finalize when height is done; Safari can fire transform earlier and cause snaps.
					if (e.propertyName !== 'height') return;
					cleanup();
				};
				card.__layoutAnimOnEnd = onEnd;
				card.addEventListener('transitionend', onEnd);
				card.__layoutAnimTimer = window.setTimeout(cleanup, duration + 240);

				// Double-rAF makes the start frame more stable across browsers (Safari included).
				window.requestAnimationFrame(() => {
					window.requestAnimationFrame(() => {
						card.style.transition = `height ${duration}ms ${easing}`;
						card.style.height = `${lastHeight}px`;
					});
				});
			}

			function animateLoginLayoutChange(changeFn) {
				const card = getLoginCard();
				if (!card || prefersReducedMotion) {
					changeFn();
					return;
				}

				// Cancel any in-flight layout animation to avoid jitter/stacking.
				if (card.__layoutAnimCleanup) {
					try {
						card.__layoutAnimCleanup();
					} catch {
						// ignore
					}
				}

				const firstHeight = card.getBoundingClientRect().height;
				changeFn();
				const lastHeight = card.getBoundingClientRect().height;
				if (Math.abs(firstHeight - lastHeight) < 0.5) return;

				const duration = 720;
				const easing = 'cubic-bezier(0.18, 1, 0.34, 1)';

				const prevWillChange = card.style.willChange;
				const prevOverflow = card.style.overflow;
				const prevTransition = card.style.transition;
				const restoreBackdrop = temporarilyDisableBackdrop(card);

				card.style.willChange = 'height';
				card.style.overflow = 'hidden';
				card.style.transition = 'none';
				card.style.height = `${firstHeight}px`;
				void card.offsetHeight;

				let finished = false;
				const cleanup = () => {
					if (finished) return;
					finished = true;
					if (card.__layoutAnimOnEnd) {
						card.removeEventListener('transitionend', card.__layoutAnimOnEnd);
						card.__layoutAnimOnEnd = null;
					}
					if (card.__layoutAnimTimer) {
						window.clearTimeout(card.__layoutAnimTimer);
						card.__layoutAnimTimer = null;
					}
					card.style.transition = 'none';
					card.style.height = `${lastHeight}px`;
					void card.offsetHeight;

					window.requestAnimationFrame(() => {
						card.style.willChange = prevWillChange;
						card.style.overflow = prevOverflow;
						card.style.height = '';
						card.style.transition = prevTransition;
						restoreBackdrop();
						card.__layoutAnimCleanup = null;
					});
				};
				card.__layoutAnimCleanup = cleanup;

				const onEnd = (e) => {
					if (e.target !== card) return;
					if (e.propertyName !== 'height') return;
					cleanup();
				};
				card.__layoutAnimOnEnd = onEnd;
				card.addEventListener('transitionend', onEnd);
				card.__layoutAnimTimer = window.setTimeout(cleanup, duration + 240);

				window.requestAnimationFrame(() => {
					window.requestAnimationFrame(() => {
						card.style.transition = `height ${duration}ms ${easing}`;
						card.style.height = `${lastHeight}px`;
					});
				});
			}

			function replayPanelAnimation(panel) {
				if (!panel) return;
				panel.style.animation = 'none';
				void panel.offsetWidth; // reflow
				panel.style.animation = '';
			}

			function selectTab(selectedId) {
				if (!selectedId) return;
				animateAppLayoutChange(() => {
					for (const { tab, panel } of tabs) {
						if (!tab || !panel) continue;
						const selected = tab.id === selectedId;
						tab.setAttribute('aria-selected', String(selected));
						panel.hidden = !selected;
						if (selected) replayPanelAnimation(panel);
					}
				});
			}

			function selectAuthTab(selectedId) {
				if (!selectedId) return;
				animateLoginLayoutChange(() => {
					for (const { tab, panel } of authTabs) {
						if (!tab || !panel) continue;
						const selected = tab.id === selectedId;
						tab.setAttribute('aria-selected', String(selected));
						panel.hidden = !selected;
						if (selected) replayPanelAnimation(panel);
					}
				});
			}

			for (const { tab } of tabs) {
				if (!tab) continue;
				tab.addEventListener('click', () => selectTab(tab.id));
				tab.addEventListener('keydown', (e) => {
					if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
					e.preventDefault();
					const idx = tabs.findIndex((t) => t.tab === tab);
					const next = e.key === 'ArrowRight' ? (idx + 1) % tabs.length : (idx - 1 + tabs.length) % tabs.length;
					tabs[next].tab?.focus();
					selectTab(tabs[next].tab?.id);
				});
			}

			for (const { tab } of authTabs) {
				if (!tab) continue;
				tab.addEventListener('click', () => selectAuthTab(tab.id));
				tab.addEventListener('keydown', (e) => {
					if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight') return;
					e.preventDefault();
					const idx = authTabs.findIndex((t) => t.tab === tab);
					const next = e.key === 'ArrowRight' ? (idx + 1) % authTabs.length : (idx - 1 + authTabs.length) % authTabs.length;
					authTabs[next].tab?.focus();
					selectAuthTab(authTabs[next].tab?.id);
				});
			}

			function normalizeUsername(usernameRaw) {
				const username = String(usernameRaw || '').trim().toLowerCase();
				if (!username) return null;
				if (username.includes('@')) return null;
				if (!/^[a-z0-9._-]+$/.test(username)) return null;
				if (username.length < USERNAME_MIN_LEN || username.length > USERNAME_MAX_LEN) return null;
				return username;
			}

			function normalizeEmail(emailRaw) {
				const email = String(emailRaw || '').trim().toLowerCase();
				if (!email) return null;
				if (!email.includes('@')) return null;
				return email;
			}

			function wirePasswordToggle(inputEl, buttonEl) {
				if (!inputEl || !buttonEl) return;
				const render = () => {
					const showing = inputEl.type === 'text';
					buttonEl.textContent = showing ? 'Hide' : 'Show';
					buttonEl.setAttribute('aria-pressed', String(showing));
				};
				render();
				buttonEl.addEventListener('click', () => {
					inputEl.type = inputEl.type === 'password' ? 'text' : 'password';
					render();
					try {
						inputEl.focus();
					} catch {
						// ignore
					}
				});
			}

			wirePasswordToggle(loginPasswordEl, toggleLoginPasswordBtn);
			wirePasswordToggle(signupPasswordEl, toggleSignupPasswordBtn);
			wirePasswordToggle(acctPasswordEl, toggleAcctPasswordBtn);

			function wireEnterSubmit(panelEl, submitBtn) {
				if (!panelEl || !submitBtn) return;
				panelEl.addEventListener('keydown', (e) => {
					if (e.key !== 'Enter') return;
					if (e.isComposing) return;
					const t = e.target;
					if (!t || t.tagName !== 'INPUT') return;
					e.preventDefault();
					if (submitBtn.disabled) return;
					try {
						submitBtn.click();
					} catch {
						// ignore
					}
				});
			}

			wireEnterSubmit(document.getElementById('auth-panel-login'), loginBtn);
			wireEnterSubmit(document.getElementById('auth-panel-signup'), signupBtn);

			function withTimeout(promise, ms, label) {
				let timeoutId;
				const timeoutPromise = new Promise((_, reject) => {
					timeoutId = window.setTimeout(() => {
						reject(new Error(`${label} timed out. Check your network/adblock and Supabase status.`));
					}, ms);
				});
				return Promise.race([promise, timeoutPromise]).finally(() => {
					if (timeoutId) window.clearTimeout(timeoutId);
				});
			}

			function signInWithPasswordXHR(email, password, timeoutMs, onProgress) {
				return new Promise((resolve, reject) => {
					const xhr = new XMLHttpRequest();
					xhr.open('POST', `${SUPABASE_URL}/auth/v1/token?grant_type=password`, true);
					xhr.timeout = timeoutMs;
					xhr.setRequestHeader('Content-Type', 'application/json');
					xhr.setRequestHeader('Accept', 'application/json');
					xhr.setRequestHeader('apikey', SUPABASE_ANON_KEY);
					xhr.onreadystatechange = () => {
						try {
							if (xhr.readyState === 4) {
								onProgress?.(`Supabase response state 4 (HTTP ${xhr.status})â€¦`);
							} else {
								onProgress?.(`Supabase response state ${xhr.readyState}â€¦`);
							}
						} catch {
							// ignore
						}
					};
					xhr.onload = () => {
						let payload = null;
						try {
							payload = xhr.responseText ? JSON.parse(xhr.responseText) : null;
						} catch {
							payload = null;
						}

						if (xhr.status >= 200 && xhr.status < 300) {
							resolve(payload);
							return;
						}

						const msg =
							payload?.error_description ||
							payload?.msg ||
							payload?.message ||
							payload?.error ||
							`Sign in failed (HTTP ${xhr.status})`;
						reject(new Error(String(msg)));
					};
					xhr.onerror = () => reject(new Error('Network error during sign in'));
					xhr.onabort = () => reject(new Error('Sign in request aborted'));
					xhr.ontimeout = () => reject(new Error('Sign in timed out. Check your network/adblock.'));
					try {
						onProgress?.('Contacting Supabaseâ€¦');
					} catch {
						// ignore
					}
					xhr.send(JSON.stringify({ email, password }));
				});
			}

			function signUpXHR(email, password, username, timeoutMs, onProgress) {
				return new Promise((resolve, reject) => {
					const xhr = new XMLHttpRequest();
					xhr.open('POST', `${SUPABASE_URL}/auth/v1/signup`, true);
					xhr.timeout = timeoutMs;
					xhr.setRequestHeader('Content-Type', 'application/json');
					xhr.setRequestHeader('Accept', 'application/json');
					xhr.setRequestHeader('apikey', SUPABASE_ANON_KEY);
					xhr.onreadystatechange = () => {
						try {
							if (xhr.readyState === 4) {
								onProgress?.(`Supabase response state 4 (HTTP ${xhr.status})â€¦`);
							} else {
								onProgress?.(`Supabase response state ${xhr.readyState}â€¦`);
							}
						} catch {
							// ignore
						}
					};
					xhr.onload = () => {
						let payload = null;
						try {
							payload = xhr.responseText ? JSON.parse(xhr.responseText) : null;
						} catch {
							payload = null;
						}

						if (xhr.status >= 200 && xhr.status < 300) {
							resolve(payload);
							return;
						}

						const msg =
							payload?.error_description ||
							payload?.msg ||
							payload?.message ||
							payload?.error ||
							`Sign up failed (HTTP ${xhr.status})`;
						reject(new Error(String(msg)));
					};
					xhr.onerror = () => reject(new Error('Network error during sign up'));
					xhr.onabort = () => reject(new Error('Sign up request aborted'));
					xhr.ontimeout = () => reject(new Error('Sign up timed out. Check your network/adblock.'));
					try {
						onProgress?.('Contacting Supabaseâ€¦');
					} catch {
						// ignore
					}
					xhr.send(JSON.stringify({ email, password, data: { username } }));
				});
			}

			function authUpdateUserXHR(accessToken, patch, timeoutMs) {
				return new Promise((resolve, reject) => {
					const xhr = new XMLHttpRequest();
					xhr.open('PUT', `${SUPABASE_URL}/auth/v1/user`, true);
					xhr.timeout = timeoutMs;
					xhr.setRequestHeader('Content-Type', 'application/json');
					xhr.setRequestHeader('Accept', 'application/json');
					xhr.setRequestHeader('apikey', SUPABASE_ANON_KEY);
					xhr.setRequestHeader('Authorization', `Bearer ${accessToken}`);
					xhr.onload = () => {
						let payload = null;
						try {
							payload = xhr.responseText ? JSON.parse(xhr.responseText) : null;
						} catch {
							payload = null;
						}
						if (xhr.status >= 200 && xhr.status < 300) {
							resolve(payload);
							return;
						}
						const msg =
							payload?.error_description ||
							payload?.msg ||
							payload?.message ||
							payload?.error ||
							`Update failed (HTTP ${xhr.status})`;
						reject(new Error(String(msg)));
					};
					xhr.onerror = () => reject(new Error('Network error updating account'));
					xhr.ontimeout = () => reject(new Error('Account update timed out'));
					xhr.send(JSON.stringify(patch || {}));
				});
			}

			async function deleteAccountViaFunction(accessToken) {
				const res = await fetch(`${SUPABASE_URL}/functions/v1/delete-account`, {
					method: 'POST',
					headers: {
						apikey: SUPABASE_ANON_KEY,
						Authorization: `Bearer ${accessToken}`,
						'Content-Type': 'application/json',
						Accept: 'application/json',
					},
					body: JSON.stringify({}),
				});
				if (res.ok) return;
				let bodyText = '';
				try {
					bodyText = await res.text();
				} catch {
					bodyText = '';
				}
				const suffix = bodyText ? `: ${bodyText}` : '';
				throw new Error(`Delete account function failed (HTTP ${res.status})${suffix}`);
			}

			function startStatusTicker(prefix) {
				const startedAt = Date.now();
				let ticks = 0;
				const render = () => {
					ticks += 1;
					const seconds = ((Date.now() - startedAt) / 1000).toFixed(1);
					if (!inApp) setLoginDebugText(`${prefix} (${seconds}s, tick ${ticks})`);
				};
				render();
				const id = window.setInterval(render, 250);
				return () => window.clearInterval(id);
			}

			async function lookupEmailForUsername(supabase, username) {
				const { data, error } = await withTimeout(
					supabase.from('usernames').select('email').eq('username', username).maybeSingle(),
					AUTH_TIMEOUT_MS,
					'Username lookup',
				);
				if (error) throw error;
				return data?.email ? String(data.email) : null;
			}

			const missingConfig =
				!SUPABASE_URL ||
				!SUPABASE_ANON_KEY ||
				SUPABASE_URL.startsWith('YOUR_') ||
				SUPABASE_ANON_KEY.startsWith('YOUR_');

			if (missingConfig) {
				showLogin('Missing Supabase config (edit index.html).');
				setButtonsDisabled(true);
			} else if (!globalThis.supabase?.createClient) {
				showLogin('Failed to load Supabase client.');
				setButtonsDisabled(true);
			} else {
				function storageAvailable() {
					try {
						const k = '__ectl_storage_test__';
						window.localStorage.setItem(k, '1');
						window.localStorage.removeItem(k);
						return true;
					} catch {
						return false;
					}
				}

				const canPersist = storageAvailable();
				const supabase = globalThis.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
					auth: {
						persistSession: canPersist,
						autoRefreshToken: canPersist,
					},
				});
				let activeUserId = null;
				let activeUser = null;
				let activeAccessToken = null;
				let activeUsingRest = false;
				let applySessionInFlight = null;
				let applySessionRun = 0;

				async function pingSupabase() {
					const res = await fetch(`${SUPABASE_URL}/auth/v1/health`, {
						method: 'GET',
						mode: 'cors',
						headers: {
							apikey: SUPABASE_ANON_KEY,
						},
					});
					return res.status;
				}

				async function lookupEmailForUsernameRest(username) {
					const url = `${SUPABASE_URL}/rest/v1/usernames?select=email&username=eq.${encodeURIComponent(username)}`;
					const res = await fetch(url, {
						method: 'GET',
						headers: {
							apikey: SUPABASE_ANON_KEY,
							Accept: 'application/json',
						},
					});
					if (!res.ok) throw new Error(`Username lookup failed (HTTP ${res.status})`);
					const arr = await res.json();
					const email = Array.isArray(arr) && arr.length ? arr[0]?.email : null;
					return email ? String(email) : null;
				}

				async function restUpsertUsernameMapping(username, userId, email, accessToken) {
					const res = await fetch(`${SUPABASE_URL}/rest/v1/usernames`, {
						method: 'POST',
						headers: {
							apikey: SUPABASE_ANON_KEY,
							Authorization: `Bearer ${accessToken}`,
							'Content-Type': 'application/json',
							Prefer: 'resolution=merge-duplicates',
							Accept: 'application/json',
						},
						body: JSON.stringify([
							{
								username,
								user_id: userId,
								email,
							},
						]),
					});
					if (!res.ok) {
						let msg = `Failed to save username mapping (HTTP ${res.status})`;
						try {
							const t = await res.text();
							if (t) msg = `${msg}: ${t}`;
						} catch {
							// ignore
						}
						throw new Error(msg);
					}
				}

				function enterRestMode(user, accessToken) {
					if (!user?.id) {
						showLogin('Sign in succeeded but user data is missing.');
						return false;
					}
					activeUsingRest = true;
					activeAccessToken = accessToken;
					activeUserId = user.id;
					activeUser = user;
					const displayName = user.user_metadata?.username || user.email || 'Account';
					showApp(`${displayName} (REST mode)`);
					if (appEl?.hidden) {
						setLoginStatusText('Internal error: app did not become visible after sign-in.');
					}
					if (acctCurrentEl) {
						const username = user.user_metadata?.username ? `@${user.user_metadata.username}` : '(no username set)';
						acctCurrentEl.textContent = `Signed in as ${username} â€” ${user.email || ''}`.trim();
					}
					if (acctUsernameEl) acctUsernameEl.value = '';
					if (acctPasswordEl) acctPasswordEl.value = '';
					setAccountStatus('');
					// Load and apply this account's saved preferences
					loadPrefs(user.id);
					return true;
				}

				async function restDeleteByUserId(table, userId, accessToken) {
					const res = await fetch(`${SUPABASE_URL}/rest/v1/${table}?user_id=eq.${encodeURIComponent(userId)}`, {
						method: 'DELETE',
						headers: {
							apikey: SUPABASE_ANON_KEY,
							Authorization: `Bearer ${accessToken}`,
							Prefer: 'return=minimal',
						},
					});
					if (!res.ok) throw new Error(`Failed to delete from ${table} (HTTP ${res.status})`);
				}

				async function restSaveUsernameMapping(username, userId, email, accessToken) {
					// Try update-by-user_id first; if no row exists, fall back to insert.
					const patchRes = await fetch(`${SUPABASE_URL}/rest/v1/usernames?user_id=eq.${encodeURIComponent(userId)}`, {
						method: 'PATCH',
						headers: {
							apikey: SUPABASE_ANON_KEY,
							Authorization: `Bearer ${accessToken}`,
							'Content-Type': 'application/json',
							Prefer: 'return=representation',
							Accept: 'application/json',
						},
						body: JSON.stringify({ username, email, user_id: userId }),
					});
					if (patchRes.ok) {
						const arr = await patchRes.json().catch(() => []);
						if (Array.isArray(arr) && arr.length) return;
					}
					await restUpsertUsernameMapping(username, userId, email, accessToken);
				}

				// â”€â”€ Multi-doc notes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

				// In-memory store: [{ id, title, content, updated_at }]
				let noteDocs = [];
				let activeDocId = null;
				let docSaveTimer = null;

				const docListEl      = document.getElementById('doc-list');
				const docTitleEl     = document.getElementById('doc-title');
				const newDocBtn      = document.getElementById('btn-new-doc');
				const renameDocBtn   = document.getElementById('btn-rename-doc');
				const deleteDocBtn   = document.getElementById('btn-delete-doc');
				const dlDocBtn       = document.getElementById('btn-dl-doc');
				const dlAllBtn       = document.getElementById('btn-dl-all');

				function notesLocalKey(userId) { return `ectl_notedocs_${userId}`; }

				function saveDocsLocally(userId) {
					try { localStorage.setItem(notesLocalKey(userId), JSON.stringify(noteDocs)); } catch { /* ignore */ }
				}

				function loadDocsLocally(userId) {
					try {
						const raw = localStorage.getItem(notesLocalKey(userId));
						return raw ? JSON.parse(raw) : null;
					} catch { return null; }
				}

				function genId() {
					return Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
				}

				function fmtDate(iso) {
					if (!iso) return '';
					const d = new Date(iso);
					const now = new Date();
					const sameDay = d.toDateString() === now.toDateString();
					if (sameDay) return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
					return d.toLocaleDateString([], { month: 'short', day: 'numeric' });
				}

				function renderDocList() {
					if (!docListEl) return;
					docListEl.innerHTML = '';
					const sorted = [...noteDocs].sort((a, b) => new Date(b.updated_at) - new Date(a.updated_at));
					for (const doc of sorted) {
						const btn = document.createElement('button');
						btn.className = 'doc-item' + (doc.id === activeDocId ? ' active' : '');
						btn.type = 'button';
						btn.setAttribute('role', 'listitem');
						btn.innerHTML = `
							<span class="doc-item-name">${escHtml(doc.title || 'Untitled')}</span>
							<span class="doc-item-date">${fmtDate(doc.updated_at)}</span>
						`;
						btn.addEventListener('click', () => switchDoc(doc.id));
						docListEl.appendChild(btn);
					}
				}

				function escHtml(s) {
					return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
				}

				function switchDoc(id) {
					// Flush any pending save to the old doc first
					if (docSaveTimer) { clearTimeout(docSaveTimer); docSaveTimer = null; }
					if (activeDocId && notesEl) {
						const prev = noteDocs.find(d => d.id === activeDocId);
						if (prev) prev.content = notesEl.value;
					}
					activeDocId = id;
					const doc = noteDocs.find(d => d.id === id);
					if (!doc) return;
					if (notesEl)    { notesEl.value = doc.content ?? ''; }
					if (docTitleEl) { docTitleEl.value = doc.title ?? ''; }
					notesEl?.focus();
					renderDocList();
				}

				function createDoc(title) {
					return { id: genId(), title: title || 'Untitled', content: '', updated_at: new Date().toISOString() };
				}

				// â”€â”€ REST helpers for note_docs table â”€â”€
				async function restGetDocs(userId, accessToken) {
					const url = `${SUPABASE_URL}/rest/v1/note_docs?select=id,title,content,updated_at&user_id=eq.${encodeURIComponent(userId)}&order=updated_at.desc`;
					const res = await fetch(url, {
						headers: { apikey: SUPABASE_ANON_KEY, Authorization: `Bearer ${accessToken}`, Accept: 'application/json' },
					});
					if (!res.ok) throw new Error(`Docs load failed (HTTP ${res.status})`);
					return res.json();
				}

				async function restUpsertDoc(userId, doc, accessToken) {
					const res = await fetch(`${SUPABASE_URL}/rest/v1/note_docs?on_conflict=id`, {
						method: 'POST',
						headers: {
							apikey: SUPABASE_ANON_KEY,
							Authorization: `Bearer ${accessToken}`,
							'Content-Type': 'application/json',
							Prefer: 'resolution=merge-duplicates',
							Accept: 'application/json',
						},
						body: JSON.stringify([{ id: doc.id, user_id: userId, title: doc.title, content: doc.content, updated_at: doc.updated_at }]),
					});
					if (!res.ok) {
						let d = ''; try { d = await res.text(); } catch { /* ignore */ }
						throw new Error(`HTTP ${res.status}${d ? ': ' + d : ''}`);
					}
				}

				async function restDeleteDoc(userId, docId, accessToken) {
					const res = await fetch(`${SUPABASE_URL}/rest/v1/note_docs?id=eq.${encodeURIComponent(docId)}&user_id=eq.${encodeURIComponent(userId)}`, {
						method: 'DELETE',
						headers: { apikey: SUPABASE_ANON_KEY, Authorization: `Bearer ${accessToken}`, Prefer: 'return=minimal' },
					});
					if (!res.ok) throw new Error(`Doc delete failed (HTTP ${res.status})`);
				}

				// â”€â”€ Load / save â”€â”€
				async function loadNotes(userId) {
					if (!notesEl) return;
					notesEl.disabled = true;
					setSaveStatus('Loadingâ€¦');
					try {
						const rows = await withTimeout(restGetDocs(userId, activeAccessToken), AUTH_TIMEOUT_MS, 'Docs load');
						noteDocs = Array.isArray(rows) ? rows : [];
						saveDocsLocally(userId);
					} catch (e) {
						console.warn('Cloud docs load failed, using localStorage:', e?.message);
						const local = loadDocsLocally(userId);
						noteDocs = Array.isArray(local) ? local : [];
					}
					// Ensure at least one document
					if (noteDocs.length === 0) { const d = createDoc('My Notes'); noteDocs.push(d); }
					notesEl.disabled = false;
					notesEl.placeholder = 'Write your notes hereâ€¦';
					switchDoc(noteDocs[0].id);
					renderDocList();
					setSaveStatus('');
				}

				async function saveCurrentDoc() {
					if (!activeDocId || !activeUserId) return;
					const doc = noteDocs.find(d => d.id === activeDocId);
					if (!doc) return;
					if (notesEl) doc.content = notesEl.value;
					doc.updated_at = new Date().toISOString();
					saveDocsLocally(activeUserId);
					renderDocList();
					setSaveStatus('Savingâ€¦');
					try {
						await withTimeout(restUpsertDoc(activeUserId, doc, activeAccessToken), AUTH_TIMEOUT_MS, 'Doc save');
						setSaveStatus('Saved');
					} catch (e) {
						console.warn('Cloud save failed, kept locally:', e?.message);
						setSaveStatus('Saved locally');
					}
					window.setTimeout(() => setSaveStatus(''), 1400);
				}

				function scheduleDocSave() {
					if (docSaveTimer) clearTimeout(docSaveTimer);
					docSaveTimer = setTimeout(saveCurrentDoc, 600);
				}

				if (notesEl) notesEl.addEventListener('input', scheduleDocSave);

				// â”€â”€ New doc â”€â”€
				if (newDocBtn) {
					newDocBtn.addEventListener('click', () => {
						const title = prompt('Document title:', 'Untitled');
						if (title === null) return; // cancelled
						const doc = createDoc(title.trim() || 'Untitled');
						noteDocs.unshift(doc);
						renderDocList();
						switchDoc(doc.id);
						if (activeUserId) saveDocsLocally(activeUserId);
						// Also save to cloud immediately
						if (activeUserId && activeAccessToken) {
							restUpsertDoc(activeUserId, doc, activeAccessToken).catch(e => console.warn('New doc cloud save:', e?.message));
						}
					});
				}

				// â”€â”€ Rename doc â”€â”€
				if (renameDocBtn) {
					renameDocBtn.addEventListener('click', () => {
						const doc = noteDocs.find(d => d.id === activeDocId);
						if (!doc) return;
						const newTitle = (docTitleEl?.value ?? '').trim();
						if (!newTitle) return;
						doc.title = newTitle;
						doc.updated_at = new Date().toISOString();
						renderDocList();
						if (activeUserId) saveDocsLocally(activeUserId);
						if (activeUserId && activeAccessToken) {
							restUpsertDoc(activeUserId, doc, activeAccessToken).catch(e => console.warn('Rename cloud save:', e?.message));
						}
					});
				}

				// â”€â”€ Delete doc â”€â”€
				if (deleteDocBtn) {
					deleteDocBtn.addEventListener('click', async () => {
						const doc = noteDocs.find(d => d.id === activeDocId);
						if (!doc) return;
						if (!confirm(`Delete "${doc.title}"? This cannot be undone.`)) return;
						noteDocs = noteDocs.filter(d => d.id !== activeDocId);
						if (activeUserId) {
							saveDocsLocally(activeUserId);
							if (activeAccessToken) restDeleteDoc(activeUserId, doc.id, activeAccessToken).catch(e => console.warn('Delete cloud:', e?.message));
						}
						if (noteDocs.length === 0) { const d = createDoc('My Notes'); noteDocs.push(d); }
						switchDoc(noteDocs[0].id);
						renderDocList();
					});
				}

				// â”€â”€ Download single doc as .txt â”€â”€
				if (dlDocBtn) {
					dlDocBtn.addEventListener('click', () => {
						const doc = noteDocs.find(d => d.id === activeDocId);
						if (!doc) return;
						if (notesEl) doc.content = notesEl.value;
						const blob = new Blob([doc.content ?? ''], { type: 'text/plain' });
						const a = document.createElement('a');
						a.href = URL.createObjectURL(blob);
						a.download = `${(doc.title || 'note').replace(/[^\w\s-]/g, '')}.txt`;
						a.click();
						URL.revokeObjectURL(a.href);
					});
				}

				// â”€â”€ Download all docs as .zip (pure JS, no library needed) â”€â”€
				if (dlAllBtn) {
					dlAllBtn.addEventListener('click', async () => {
						// Flush current editor content
						if (activeDocId && notesEl) {
							const cur = noteDocs.find(d => d.id === activeDocId);
							if (cur) cur.content = notesEl.value;
						}
						const zip = buildZip(noteDocs.map(doc => ({
							name: `${(doc.title || 'note').replace(/[^\w\s-]/g, '') || 'note'}.txt`,
							data: doc.content ?? '',
						})));
						const blob = new Blob([zip], { type: 'application/zip' });
						const a = document.createElement('a');
						a.href = URL.createObjectURL(blob);
						a.download = 'notes.zip';
						a.click();
						URL.revokeObjectURL(a.href);
					});
				}

				// Minimal pure-JS ZIP builder (STORE method, no compression â€“ fine for text)
				function buildZip(files) {
					const enc = new TextEncoder();
					const parts = [];
					const centralDir = [];
					let offset = 0;

					function u16(n) { const b = new Uint8Array(2); new DataView(b.buffer).setUint16(0, n, true); return b; }
					function u32(n) { const b = new Uint8Array(4); new DataView(b.buffer).setUint32(0, n, true); return b; }

					function crc32(data) {
						let crc = 0xFFFFFFFF;
						for (const byte of data) {
							crc ^= byte;
							for (let i = 0; i < 8; i++) crc = (crc & 1) ? (crc >>> 1) ^ 0xEDB88320 : crc >>> 1;
						}
						return (crc ^ 0xFFFFFFFF) >>> 0;
					}

					for (const file of files) {
						const nameBytes = enc.encode(file.name);
						const dataBytes = enc.encode(file.data);
						const crc = crc32(dataBytes);
						const local = new Uint8Array([
							...u32(0x04034b50), // local file header sig
							...u16(20), ...u16(0), ...u16(0), // version, flags, method (STORE)
							...u16(0), ...u16(0),             // mod time/date
							...u32(crc),
							...u32(dataBytes.length), ...u32(dataBytes.length), // compressed = uncompressed
							...u16(nameBytes.length), ...u16(0),
							...nameBytes,
							...dataBytes,
						]);
						parts.push(local);
						centralDir.push(new Uint8Array([
							...u32(0x02014b50), // central dir sig
							...u16(20), ...u16(20), ...u16(0), ...u16(0), ...u16(0),
							...u16(0), ...u16(0),
							...u32(crc),
							...u32(dataBytes.length), ...u32(dataBytes.length),
							...u16(nameBytes.length), ...u16(0), ...u16(0), ...u16(0), ...u16(0),
							...u32(0), ...u32(offset),
							...nameBytes,
						]));
						offset += local.length;
					}

					const cdSize = centralDir.reduce((s, b) => s + b.length, 0);
					const eocd = new Uint8Array([
						...u32(0x06054b50),
						...u16(0), ...u16(0),
						...u16(files.length), ...u16(files.length),
						...u32(cdSize), ...u32(offset),
						...u16(0),
					]);

					const total = [...parts, ...centralDir, eocd].reduce((s,b) => s+b.length, 0);
					const out = new Uint8Array(total);
					let pos = 0;
					for (const b of [...parts, ...centralDir, eocd]) { out.set(b, pos); pos += b.length; }
					return out;
				}

				// â”€â”€ end multi-doc notes â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

				async function applySession(session, label) {
					if (applySessionInFlight) return applySessionInFlight;
					applySessionRun += 1;
					const runId = applySessionRun;
					const authLabel = label ? String(label) : 'unknown';
					applySessionInFlight = (async () => {
						try {
							const user = session?.user ?? null;
							if (!user) {
								activeUserId = null;
								const persistNote = canPersist ? '' : ' Storage blocked; session will not persist.';
								showLogin(`Signed out (auth ${authLabel} #${runId}).${persistNote}`);
								return;
							}

							activeUserId = user.id;
							const displayName = user.user_metadata?.username || user.email || 'Account';
							if (activeUsingRest) {
								showApp(`${displayName} (REST mode)`);
							} else {
							showApp(displayName);
							}
							await loadNotes(user.id);
						} catch (e) {
							activeUserId = null;
							showLogin(friendlyAuthError(e?.message || String(e)));
						} finally {
							applySessionInFlight = null;
						}
					})();
					return applySessionInFlight;
				}

				async function bootstrap() {
					const stopTick = startStatusTicker('Bootstrappingâ€¦');
					try {
						const status = await withTimeout(pingSupabase(), 6000, 'Supabase ping');
						const persistNote = canPersist ? '' : ' Storage blocked; session will not persist.';
						if (!inApp) setLoginDebugText(`Supabase ping: HTTP ${status}. Ready.${persistNote}`);
					} catch (e) {
						if (!inApp) setLoginDebugText(`Supabase error: ${friendlyAuthError(e?.message || String(e))}`);
					} finally {
						stopTick();
					}
				}

				function friendlyAuthError(messageRaw) {
					const message = String(messageRaw || 'Unknown error');
					if (message.toLowerCase().includes('email not confirmed')) {
						return 'Email not confirmed. Confirm it, or disable â€œConfirm emailâ€ in Supabase Auth settings.';
					}
					return message;
				}

				if (loginBtn) {
					loginBtn.addEventListener('click', async () => {
						setButtonsDisabled(true);
						try {
							const identifier = String(loginIdentifierEl?.value || '');
							const emailDirect = normalizeEmail(identifier);
							const username = emailDirect ? null : normalizeUsername(identifier);
							const password = String(loginPasswordEl?.value || '');
							if ((!emailDirect && !username) || !password) {
								showLogin('Enter username/email + password');
								return;
							}

							let email = emailDirect;
							if (!email && username) {
								try {
									const stopTick = startStatusTicker('Looking up usernameâ€¦');
									email = await withTimeout(lookupEmailForUsernameRest(username), AUTH_TIMEOUT_MS, 'Username lookup').finally(stopTick);
								} catch (e) {
									showLogin(friendlyAuthError(e?.message || String(e)));
									return;
								}
								if (!email) {
									showLogin('Username not found');
									return;
								}
							}

							showLogin('Signing inâ€¦');
							const tokenData = await signInWithPasswordXHR(email, password, AUTH_TIMEOUT_MS, (msg) => {
								if (!inApp) setLoginDebugText(`Signing inâ€¦ ${msg}`);
							});

							const access_token = tokenData?.access_token;
							const refresh_token = tokenData?.refresh_token;
							if (!access_token || !refresh_token) {
								showLogin('Sign in failed: missing tokens from Supabase');
								return;
							}
							// Use REST mode directly (supabase-js session restore/apply is hanging in this environment)
							activeUsingRest = true;
							activeAccessToken = access_token;
							if (loginPasswordEl) loginPasswordEl.value = '';
							const user = tokenData?.user ?? null;
							setLoginStatusText('Entering appâ€¦');
							if (!enterRestMode(user, access_token)) return;
							// Allow the UI to paint before the notes fetch
							await new Promise((r) => window.requestAnimationFrame(() => r()));
							await loadNotes(user.id);
						} catch (e) {
							showLogin(friendlyAuthError(e?.message || String(e)));
						} finally {
							setButtonsDisabled(false);
						}
					});
				}

				if (signupBtn) {
					signupBtn.addEventListener('click', async () => {
						setButtonsDisabled(true);
						try {
							const username = normalizeUsername(signupUsernameEl?.value);
							const email = normalizeEmail(signupEmailEl?.value);
							const password = String(signupPasswordEl?.value || '');
							if (!username || !email || !password) {
								showLogin('Create account requires username + email + password');
								selectAuthTab('auth-tab-signup');
								return;
							}
							showLogin('Creating accountâ€¦');
							const payload = await signUpXHR(email, password, username, AUTH_TIMEOUT_MS, (msg) => {
								setLoginDebugText(`Creating accountâ€¦ ${msg}`);
							});
							const access_token = payload?.access_token;
							const refresh_token = payload?.refresh_token;
							const userId = payload?.user?.id;
							if (userId && (!access_token || !refresh_token)) {
								showLogin('Account created. Confirm your email, then log in (username login works after first login).');
								return;
							}

							// REST mode directly
							activeUsingRest = true;
							activeAccessToken = access_token;
							if (userId) {
								const stopTick = startStatusTicker('Saving usernameâ€¦');
								await withTimeout(restUpsertUsernameMapping(username, userId, email, access_token), AUTH_TIMEOUT_MS, 'Saving username').finally(stopTick);
							}
							if (signupPasswordEl) signupPasswordEl.value = '';
							const user = payload?.user ?? null;
							setLoginStatusText('Entering appâ€¦');
							if (!enterRestMode(user, access_token)) return;
							await new Promise((r) => window.requestAnimationFrame(() => r()));
							await loadNotes(user.id);
						} catch (e) {
							showLogin(friendlyAuthError(e?.message || String(e)));
						} finally {
							setButtonsDisabled(false);
						}
					});
				}

				if (signOutBtn) {
					signOutBtn.addEventListener('click', async () => {
						try {
							if (!activeUsingRest) {
								try {
									await withTimeout(supabase.auth.signOut(), AUTH_TIMEOUT_MS, 'Sign out');
								} catch {
									// ignore supabase sign-out errors; we clear local state regardless
								}
							}
						} finally {
							// Clear all local auth state immediately.
							activeUsingRest = false;
							activeUser = null;
							activeAccessToken = null;
							activeUserId = null;
							// Reset the in-flight guard so a second sign-out/login is never blocked.
							applySessionInFlight = null;
							// Reset preferences to defaults
							applyPrefs({ accentIndex: 0, fontSize: 'medium', cardWidth: 'regular', bgStyle: 'aurora' });
							showLogin('Signed out.');
						}
					});
				}

				if (updateUsernameBtn) {
					updateUsernameBtn.addEventListener('click', async () => {
						try {
							if (!activeUserId || !activeAccessToken || !activeUser) {
								setAccountStatus('Not signed in');
								return;
							}
							const newUsername = normalizeUsername(acctUsernameEl?.value);
							if (!newUsername) {
								setAccountStatus('Enter a valid username');
								return;
							}

							setAccountStatus('Checking usernameâ€¦');
							const takenByEmail = await withTimeout(lookupEmailForUsernameRest(newUsername), AUTH_TIMEOUT_MS, 'Username lookup');
							if (takenByEmail && String(takenByEmail).toLowerCase() !== String(activeUser.email || '').toLowerCase()) {
								setAccountStatus('That username is taken');
								return;
							}

							setAccountStatus('Updating usernameâ€¦');
							const updated = await authUpdateUserXHR(activeAccessToken, { data: { username: newUsername } }, AUTH_TIMEOUT_MS);
							activeUser = updated || activeUser;
							if (!activeUser.user_metadata) activeUser.user_metadata = {};
							activeUser.user_metadata.username = newUsername;

							setAccountStatus('Saving username mappingâ€¦');
							await withTimeout(restSaveUsernameMapping(newUsername, activeUserId, activeUser.email, activeAccessToken), AUTH_TIMEOUT_MS, 'Saving username');

							enterRestMode(activeUser, activeAccessToken);
							setAccountStatus('Username updated');
							if (acctUsernameEl) acctUsernameEl.value = '';
						} catch (e) {
							setAccountStatus(friendlyAuthError(e?.message || String(e)));
						}
					});
				}

				if (updatePasswordBtn) {
					updatePasswordBtn.addEventListener('click', async () => {
						try {
							if (!activeAccessToken) {
								setAccountStatus('Not signed in');
								return;
							}
							const newPassword = String(acctPasswordEl?.value || '');
							if (!newPassword) {
								setAccountStatus('Enter a new password');
								return;
							}
							setAccountStatus('Updating passwordâ€¦');
							await authUpdateUserXHR(activeAccessToken, { password: newPassword }, AUTH_TIMEOUT_MS);
							if (acctPasswordEl) acctPasswordEl.value = '';
							setAccountStatus('Password updated');
						} catch (e) {
							setAccountStatus(friendlyAuthError(e?.message || String(e)));
						}
					});
				}

				if (deleteAccountBtn) {
					deleteAccountBtn.addEventListener('click', async () => {
						try {
							if (!activeUserId || !activeAccessToken) {
								setAccountStatus('Not signed in');
								return;
							}
							const ok = window.confirm('Delete your account? This will delete your notes and username mapping too.');
							if (!ok) return;

							setAccountStatus('Deleting notesâ€¦');
							await withTimeout(restDeleteByUserId('notes', activeUserId, activeAccessToken), AUTH_TIMEOUT_MS, 'Delete notes');
							setAccountStatus('Deleting username mappingâ€¦');
							await withTimeout(restDeleteByUserId('usernames', activeUserId, activeAccessToken), AUTH_TIMEOUT_MS, 'Delete usernames');
							setAccountStatus('Deleting auth accountâ€¦');
							try {
								await withTimeout(deleteAccountViaFunction(activeAccessToken), AUTH_TIMEOUT_MS, 'Delete account');
							} catch (e) {
								setAccountStatus(
									`Deleted your data, but could not delete the auth user. ${friendlyAuthError(e?.message || String(e))}`,
								);
								return;
							}

							activeUsingRest = false;
							activeUser = null;
							activeAccessToken = null;
							activeUserId = null;
							showLogin('Account deleted');
						} catch (e) {
							setAccountStatus(friendlyAuthError(e?.message || String(e)));
						}
					});
				}

				// â”€â”€ Files tab â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
				const FILES_BUCKET = 'user-files';

				const filesUploadZoneEl = document.getElementById('files-upload-zone');
				const filesInputEl = document.getElementById('files-input');
				const filesUploadProgressEl = document.getElementById('files-upload-progress');
				const filesUploadBarEl = document.getElementById('files-upload-bar');
				const filesStatusEl = document.getElementById('files-status');
				const fileListEl = document.getElementById('file-list');

				function setFilesStatus(text) {
					if (filesStatusEl) filesStatusEl.textContent = text || '';
				}

				function formatBytes(bytes) {
					if (bytes == null) return '';
					if (bytes < 1024) return `${bytes} B`;
					if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
					return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
				}

				function formatDate(iso) {
					if (!iso) return '';
					try {
						return new Date(iso).toLocaleDateString(undefined, { month: 'short', day: 'numeric', year: 'numeric' });
					} catch {
						return '';
					}
				}

				// Storage path is user-scoped so RLS/policies can gate by prefix.
				function storagePath(fileName) {
					return `${activeUserId}/${fileName}`;
				}

				async function storageListFiles() {
					const res = await fetch(
						`${SUPABASE_URL}/storage/v1/object/list/${FILES_BUCKET}`,
						{
							method: 'POST',
							headers: {
								apikey: SUPABASE_ANON_KEY,
								Authorization: `Bearer ${activeAccessToken}`,
								'Content-Type': 'application/json',
							},
							body: JSON.stringify({ prefix: `${activeUserId}/`, limit: 200, offset: 0, sortBy: { column: 'created_at', order: 'desc' } }),
						},
					);
					if (!res.ok) throw new Error(`List files failed (HTTP ${res.status})`);
					const items = await res.json();
					// Filter out placeholder folders (name ends with /)
					return (Array.isArray(items) ? items : []).filter((f) => f.name && !f.name.endsWith('/'));
				}

				async function storageUploadFile(file, onProgress) {
					// Use XHR so we can get upload progress.
					const path = storagePath(file.name);
					return new Promise((resolve, reject) => {
						const xhr = new XMLHttpRequest();
						// Use PUT with upsert header so re-uploading the same file works.
						xhr.open('POST', `${SUPABASE_URL}/storage/v1/object/${FILES_BUCKET}/${encodeURIComponent(path)}`, true);
						xhr.setRequestHeader('apikey', SUPABASE_ANON_KEY);
						xhr.setRequestHeader('Authorization', `Bearer ${activeAccessToken}`);
						xhr.setRequestHeader('x-upsert', 'true');
						xhr.setRequestHeader('Content-Type', file.type || 'application/octet-stream');
						xhr.upload.onprogress = (e) => {
							if (e.lengthComputable) onProgress?.(e.loaded / e.total);
						};
						xhr.onload = () => {
							if (xhr.status >= 200 && xhr.status < 300) {
								resolve();
							} else {
								let msg = `Upload failed (HTTP ${xhr.status})`;
								try { const b = JSON.parse(xhr.responseText); if (b?.message) msg = b.message; } catch {}
								reject(new Error(msg));
							}
						};
						xhr.onerror = () => reject(new Error('Upload network error'));
						xhr.send(file);
					});
				}

				async function storageDeleteFile(fileName) {
					const path = storagePath(fileName);
					const res = await fetch(
						`${SUPABASE_URL}/storage/v1/object/${FILES_BUCKET}/${encodeURIComponent(path)}`,
						{
							method: 'DELETE',
							headers: {
								apikey: SUPABASE_ANON_KEY,
								Authorization: `Bearer ${activeAccessToken}`,
							},
						},
					);
					if (!res.ok) throw new Error(`Delete failed (HTTP ${res.status})`);
				}

				function storageDownloadUrl(fileName) {
					// Authenticated download via signed URL approach â€” just link directly with the token.
					const path = storagePath(fileName);
					return `${SUPABASE_URL}/storage/v1/object/authenticated/${FILES_BUCKET}/${encodeURIComponent(path)}`;
				}

				async function storageDownloadFile(fileName) {
					const path = storagePath(fileName);
					const res = await fetch(
						`${SUPABASE_URL}/storage/v1/object/${FILES_BUCKET}/${encodeURIComponent(path)}`,
						{
							headers: {
								apikey: SUPABASE_ANON_KEY,
								Authorization: `Bearer ${activeAccessToken}`,
							},
						},
					);
					if (!res.ok) throw new Error(`Download failed (HTTP ${res.status})`);
					const blob = await res.blob();
					const url = URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					a.download = fileName;
					document.body.appendChild(a);
					a.click();
					document.body.removeChild(a);
					URL.revokeObjectURL(url);
				}

				async function refreshFileList() {
					if (!activeUserId || !activeAccessToken) return;
					setFilesStatus('Loadingâ€¦');
					try {
						const files = await withTimeout(storageListFiles(), AUTH_TIMEOUT_MS, 'List files');
						renderFileList(files);
						setFilesStatus(files.length === 0 ? 'No files yet.' : '');
					} catch (e) {
						console.error('Files list error', e);
						setFilesStatus(`Failed to load files: ${e?.message || e}`);
					}
				}

				function renderFileList(files) {
					if (!fileListEl) return;
					fileListEl.innerHTML = '';
					for (const f of files) {
						const row = document.createElement('div');
						row.className = 'file-row';

						const nameEl = document.createElement('span');
						nameEl.className = 'file-row-name';
						nameEl.textContent = f.name;

						const metaEl = document.createElement('span');
						metaEl.className = 'file-row-meta';
						const size = f.metadata?.size ?? f.metadata?.contentLength ?? null;
						const date = f.created_at || f.updated_at || null;
						metaEl.textContent = [formatBytes(size), formatDate(date)].filter(Boolean).join(' Â· ');

						const actionsEl = document.createElement('div');
						actionsEl.className = 'file-row-actions';

						const dlBtn = document.createElement('button');
						dlBtn.className = 'btn btn-small';
						dlBtn.textContent = 'Download';
						dlBtn.type = 'button';
						dlBtn.addEventListener('click', async () => {
							dlBtn.disabled = true;
							try {
								await storageDownloadFile(f.name);
							} catch (e) {
								setFilesStatus(`Download failed: ${e?.message || e}`);
							} finally {
								dlBtn.disabled = false;
							}
						});

						const delBtn = document.createElement('button');
						delBtn.className = 'btn btn-small';
						delBtn.textContent = 'Delete';
						delBtn.type = 'button';
						delBtn.addEventListener('click', async () => {
							if (!window.confirm(`Delete "${f.name}"?`)) return;
							delBtn.disabled = true;
							try {
								await withTimeout(storageDeleteFile(f.name), AUTH_TIMEOUT_MS, 'Delete file');
								await refreshFileList();
							} catch (e) {
								setFilesStatus(`Delete failed: ${e?.message || e}`);
								delBtn.disabled = false;
							}
						});

						actionsEl.appendChild(dlBtn);
						actionsEl.appendChild(delBtn);
						row.appendChild(nameEl);
						row.appendChild(metaEl);
						row.appendChild(actionsEl);
						fileListEl.appendChild(row);
					}
				}

				async function handleUploadFiles(fileList) {
					if (!fileList || !fileList.length) return;
					const files = Array.from(fileList);
					if (filesUploadProgressEl) filesUploadProgressEl.classList.add('visible');
					let done = 0;
					const errors = [];
					for (const file of files) {
						setFilesStatus(`Uploading ${file.name}â€¦`);
						try {
							await storageUploadFile(file, (pct) => {
								const overall = (done + pct) / files.length;
								if (filesUploadBarEl) filesUploadBarEl.style.width = `${Math.round(overall * 100)}%`;
							});
							done += 1;
							if (filesUploadBarEl) filesUploadBarEl.style.width = `${Math.round((done / files.length) * 100)}%`;
						} catch (e) {
							console.error('Upload error', e);
							errors.push(`${file.name}: ${e?.message || e}`);
						}
					}
					if (filesUploadProgressEl) filesUploadProgressEl.classList.remove('visible');
					if (filesUploadBarEl) filesUploadBarEl.style.width = '0%';
					if (filesInputEl) filesInputEl.value = '';
					if (errors.length) {
						setFilesStatus(`Errors: ${errors.join('; ')}`);
					} else {
						setFilesStatus(`${done} file${done !== 1 ? 's' : ''} uploaded.`);
					}
					await refreshFileList();
				}

				// Click to open file picker
				if (filesUploadZoneEl && filesInputEl) {
					filesUploadZoneEl.addEventListener('click', (e) => {
						if (e.target === filesInputEl) return;
						filesInputEl.click();
					});
					filesUploadZoneEl.addEventListener('keydown', (e) => {
						if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); filesInputEl.click(); }
					});
					filesInputEl.addEventListener('change', () => handleUploadFiles(filesInputEl.files));
				}

				// Drag-and-drop
				if (filesUploadZoneEl) {
					filesUploadZoneEl.addEventListener('dragover', (e) => { e.preventDefault(); filesUploadZoneEl.classList.add('drag-over'); });
					filesUploadZoneEl.addEventListener('dragleave', () => filesUploadZoneEl.classList.remove('drag-over'));
					filesUploadZoneEl.addEventListener('drop', (e) => {
						e.preventDefault();
						filesUploadZoneEl.classList.remove('drag-over');
						handleUploadFiles(e.dataTransfer?.files);
					});
				}

				// Refresh file list whenever the Files tab becomes active
				const filesTab = document.getElementById('tab-files');
				if (filesTab) {
					filesTab.addEventListener('click', () => {
						if (activeUserId && activeAccessToken) refreshFileList();
					});
				}

				// â”€â”€ Preferences â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

				const ACCENT_PRESETS = [
					{ name: 'Indigo',  light: '#5b6ef5', dark: '#818cf8' },
					{ name: 'Violet',  light: '#7c3aed', dark: '#a78bfa' },
					{ name: 'Pink',    light: '#db2777', dark: '#f472b6' },
					{ name: 'Rose',    light: '#e11d48', dark: '#fb7185' },
					{ name: 'Amber',   light: '#d97706', dark: '#fbbf24' },
					{ name: 'Emerald', light: '#059669', dark: '#34d399' },
					{ name: 'Cyan',    light: '#0891b2', dark: '#22d3ee' },
				];

				// Current pref state (defaults)
				let currentPrefs = {
					accentIndex: 0,   // index into ACCENT_PRESETS
					fontSize:    'medium',
					cardWidth:   'regular',
					bgStyle:     'aurora',
				};

				const FONT_SCALE   = { small: 0.88, medium: 1, large: 1.15 };
				const CARD_SCALE   = { compact: 0.72, regular: 1, wide: 1.22 };

				// Base card-max values (read from the stylesheet's --card-max at each bp).
				// We store base values and multiply by CARD_SCALE.
				const BASE_CARD_MAX = { base: 1060, md: 1200, lg: 1420, xl: 1680 };
				const BASE_FONT     = { base: 15, md: 16, lg: 17, xl: 18 };

				function applyPrefs(prefs) {
					currentPrefs = { ...currentPrefs, ...prefs };
					const root = document.documentElement;
					const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
					const preset = ACCENT_PRESETS[currentPrefs.accentIndex] ?? ACCENT_PRESETS[0];

					// Accent colour
					const accentColor  = isDark ? preset.dark  : preset.light;
					const accent2Color = isDark
						? ACCENT_PRESETS[(currentPrefs.accentIndex + 1) % ACCENT_PRESETS.length].dark
						: ACCENT_PRESETS[(currentPrefs.accentIndex + 1) % ACCENT_PRESETS.length].light;

					root.style.setProperty('--accent', accentColor);
					root.style.setProperty('--accent-2', accent2Color);
					// Recompute glow from accent
					root.style.setProperty('--accent-glow',   hexToRgba(accentColor,  isDark ? 0.25 : 0.22));
					root.style.setProperty('--accent-glow-2', hexToRgba(accent2Color, isDark ? 0.16 : 0.14));
					root.style.setProperty('--ring',          hexToRgba(accentColor,  isDark ? 0.40 : 0.35));

					// Font size
					const fs = FONT_SCALE[currentPrefs.fontSize] ?? 1;
					root.style.setProperty('--base-font',   `${Math.round(BASE_FONT.base * fs)}px`);

					// Card width
					const cw = CARD_SCALE[currentPrefs.cardWidth] ?? 1;
					root.style.setProperty('--card-max', `${Math.round(BASE_CARD_MAX.base * cw)}px`);

					// Background style
					applyBgStyle(currentPrefs.bgStyle);

					// Sync UI
					syncPrefsUI();
				}

				function applyBgStyle(style) {
					const body = document.body;
					// Remove any previously set custom bg class
					body.classList.remove('bg-aurora', 'bg-subtle', 'bg-minimal');
					body.classList.add(`bg-${style}`);
				}

				function hexToRgba(hex, alpha) {
					const h = hex.replace('#', '');
					const r = parseInt(h.slice(0,2),16);
					const g = parseInt(h.slice(2,4),16);
					const b = parseInt(h.slice(4,6),16);
					return `rgba(${r},${g},${b},${alpha})`;
				}

				// Inject dynamic bg-style rules once
				(function injectBgStyleRules() {
					const s = document.createElement('style');
					s.id = 'bg-style-rules';
					s.textContent = `
						body.bg-subtle::after { opacity: 0.45 !important; }
						body.bg-minimal::after { display: none !important; }
						body.bg-minimal {
							background: var(--bg) !important;
						}
					`;
					document.head.appendChild(s);
				})();

				// Build swatch row
				(function buildSwatches() {
					const row = document.getElementById('swatch-row');
					if (!row) return;
					const isDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
					ACCENT_PRESETS.forEach((p, i) => {
						const btn = document.createElement('button');
						btn.className = 'swatch';
						btn.type = 'button';
						btn.title = p.name;
						btn.setAttribute('aria-label', p.name);
						btn.dataset.index = String(i);
						btn.style.background = isDark ? p.dark : p.light;
						btn.addEventListener('click', () => {
							currentPrefs.accentIndex = i;
							applyPrefs(currentPrefs);
						});
						row.appendChild(btn);
					});
				})();

				function syncPrefsUI() {
					// Swatches
					document.querySelectorAll('.swatch').forEach(s => {
						s.classList.toggle('active', Number(s.dataset.index) === currentPrefs.accentIndex);
					});
					// Chips
					[
						{ id: 'chips-fontsize', key: 'fontSize' },
						{ id: 'chips-cardwidth', key: 'cardWidth' },
						{ id: 'chips-bgstyle',   key: 'bgStyle'   },
					].forEach(({ id, key }) => {
						document.querySelectorAll(`#${id} .chip`).forEach(c => {
							c.classList.toggle('active', c.dataset.val === currentPrefs[key]);
						});
					});
				}

				// Wire chip clicks
				['chips-fontsize','chips-cardwidth','chips-bgstyle'].forEach(id => {
					const container = document.getElementById(id);
					if (!container) return;
					const key = id === 'chips-fontsize' ? 'fontSize'
					          : id === 'chips-cardwidth' ? 'cardWidth' : 'bgStyle';
					container.addEventListener('click', e => {
						const chip = e.target.closest('.chip');
						if (!chip) return;
						currentPrefs[key] = chip.dataset.val;
						applyPrefs(currentPrefs);
					});
				});

				// REST helpers for preferences table
				async function restGetPrefs(userId, accessToken) {
					const url = `${SUPABASE_URL}/rest/v1/preferences?select=prefs&user_id=eq.${encodeURIComponent(userId)}&limit=1`;
					const res = await fetch(url, {
						headers: {
							apikey: SUPABASE_ANON_KEY,
							Authorization: `Bearer ${accessToken}`,
							Accept: 'application/json',
						},
					});
					if (!res.ok) {
						let detail = '';
						try { detail = await res.text(); } catch { /* ignore */ }
						throw new Error(`Prefs load failed (HTTP ${res.status})${detail ? ': ' + detail : ''}`);
					}
					const arr = await res.json();
					return Array.isArray(arr) && arr.length ? (arr[0]?.prefs ?? null) : null;
				}

				async function restUpsertPrefs(userId, prefs, accessToken) {
					const res = await fetch(`${SUPABASE_URL}/rest/v1/preferences?on_conflict=user_id`, {
						method: 'POST',
						headers: {
							apikey: SUPABASE_ANON_KEY,
							Authorization: `Bearer ${accessToken}`,
							'Content-Type': 'application/json',
							Prefer: 'resolution=merge-duplicates',
							Accept: 'application/json',
						},
						body: JSON.stringify([{ user_id: userId, prefs }]),
					});
					if (!res.ok) {
						let detail = '';
						try { detail = await res.text(); } catch { /* ignore */ }
						throw new Error(`HTTP ${res.status}${detail ? ': ' + detail : ''}`);
					}
				}

				// localStorage key scoped to user so multiple accounts work
				function prefsLocalKey(userId) { return `ectl_prefs_${userId}`; }

				function savePrefsLocally(userId, prefs) {
					try { localStorage.setItem(prefsLocalKey(userId), JSON.stringify(prefs)); } catch { /* ignore */ }
				}

				function loadPrefsLocally(userId) {
					try {
						const raw = localStorage.getItem(prefsLocalKey(userId));
						return raw ? JSON.parse(raw) : null;
					} catch { return null; }
				}

				async function loadPrefs(userId) {
					try {
						const saved = await restGetPrefs(userId, activeAccessToken);
						if (saved && typeof saved === 'object') {
							applyPrefs(saved);
							savePrefsLocally(userId, saved); // keep local copy in sync
							return;
						}
					} catch (e) {
						console.warn('Prefs cloud load failed, trying localStorage:', e?.message);
					}
					// Fall back to localStorage (works without the DB table)
					const local = loadPrefsLocally(userId);
					applyPrefs(local ?? currentPrefs);
				}

				const prefsStatusEl  = document.getElementById('prefs-status');
				const savePrefsBtn   = document.getElementById('btn-save-prefs');

				function setPrefsStatus(msg) {
					if (prefsStatusEl) prefsStatusEl.textContent = msg;
				}

				if (savePrefsBtn) {
					savePrefsBtn.addEventListener('click', async () => {
						if (!activeUserId || !activeAccessToken) {
							setPrefsStatus('Not signed in.');
							return;
						}
						savePrefsBtn.disabled = true;
						setPrefsStatus('Savingâ€¦');
						// Always save locally first â€” this never fails
						savePrefsLocally(activeUserId, currentPrefs);
						try {
							await withTimeout(restUpsertPrefs(activeUserId, currentPrefs, activeAccessToken), AUTH_TIMEOUT_MS, 'Prefs save');
							setPrefsStatus('Saved!');
						} catch (e) {
							console.error('Prefs cloud save failed:', e?.message);
							// Local save already succeeded â€” tell user
							setPrefsStatus(`Saved locally (cloud: ${e?.message ?? 'error'})`);
						} finally {
							savePrefsBtn.disabled = false;
							setTimeout(() => setPrefsStatus(''), 3500);
						}
					});
				}

				// â”€â”€ end preferences â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

				recenterLoginCard();
				bootstrap();
			}
		</script>
	</body>
</html>
